# N-Queen 문제 해설 및 알고리즘 증명

## N-Queen 문제란?

**N-Queen 문제**는 가로, 세로의 길이가 각각 N인 체스판 위에 N개의 퀸을 서로 공격할 수 없도록 배치하는 경우의 수를 찾는 유명한 조합 문제입니다. 퀸은 체스에서 가로, 세로, 대각선 방향으로 원하는 만큼 이동할 수 있어 강력한 기물 중 하나입니다. 따라서 N개의 퀸을 서로 공격할 수 없게 배치하려면 다음 두 가지 조건을 만족해야 합니다.

1.  **어떤 두 퀸도 같은 행(Row)이나 같은 열(Column)에 위치해서는 안 됩니다.**
2.  **어떤 두 퀸도 같은 대각선(Diagonal) 상에 위치해서는 안 됩니다.**

이 문제는 제약 충족 문제(Constraint Satisfaction Problem)의 대표적인 예시이며, **백트래킹(Backtracking)** 알고리즘을 사용하여 효과적으로 해결할 수 있습니다.

## 💻 알고리즘 설명: 백트래킹

알고리즘의 핵심 아이디어는 다음과 같습니다.

1.  **한 번에 한 열씩 퀸 배치**: 첫 번째 열부터 시작하여 각 열에 퀸을 하나씩 배치합니다. 이 방식은 자동으로 **한 열에 하나의 퀸만 배치**하는 조건을 만족시킵니다.

2.  **유망성 검사 (Promising Check)**: 특정 위치에 퀸을 놓기 전에, 그 위치가 유망한지(즉, 이전에 놓인 퀸들과 충돌하지 않는지)를 검사합니다.

      * **같은 행 검사**: `board[i] == board[col]`
      * **대각선 검사**: `abs(board[i] - board[col]) == (col - i)`
          * 두 퀸의 행 번호 차이의 절댓값과 열 번호 차이가 같으면 두 퀸은 같은 대각선 상에 있습니다.

3.  **재귀 호출과 후퇴 (Recursion & Backtracking)**:

      * 만약 현재 위치가 유망하다면, 다음 열로 이동하기 위해 재귀적으로 함수를 호출합니다.
      * 만약 현재 열의 모든 행을 시도했지만 유망한 위치를 찾지 못했다면, 이 경로는 해가 될 수 없으므로 이전 열로 되돌아갑니다. (이것이 **백트래킹**입니다.) 이전 열에서는 다음 행부터 다시 탐색을 시작합니다.
      * 이 과정을 반복하여 N개의 퀸을 모두 성공적으로 배치하면, 해의 개수를 1 증가시킵니다.

## ✅ 정확성 증명

이 백트래킹 알고리즘이 N-Queen 문제의 모든 해를 정확하게 찾는다는 것은 다음 두 가지 속성을 통해 증명할 수 있습니다.

1.  **완전성 (Completeness)**: 알고리즘은 **반드시 모든 가능한 해를 찾습니다.**

      * **이유**: 이 알고리즘은 상태 공간 트리(State-Space Tree)의 모든 노드를 체계적으로 탐색하기 때문입니다. 각 열마다 1행부터 N행까지 퀸을 놓는 모든 경우의 수를 시도합니다. 유망하지 않은 경로(Pruning)를 조기에 차단할 뿐, 해가 될 가능성이 있는 경로는 절대 버리지 않습니다. 따라서 N개의 퀸을 성공적으로 배치하는 모든 조합은 결국 발견됩니다.

2.  **정확성 (Soundness)**: 알고리즘이 찾은 결과는 **반드시 문제의 조건을 만족하는 유효한 해입니다.**

      * **이유**: 퀸을 새로 배치할 때마다, 이전에 배치된 모든 퀸들과의 충돌 여부(같은 행, 같은 대각선)를 검사합니다. 오직 충돌이 발생하지 않는 유효한 위치에만 퀸을 배치하고 다음 단계로 나아가기 때문에, 최종적으로 N개의 퀸이 모두 배치된 상태는 문제의 모든 제약 조건을 만족할 수밖에 없습니다.

결론적으로, 이 알고리즘은 **상태 공간 트리를 깊이 우선 탐색(DFS)하되, 유망하지 않은 노드는 탐색하지 않는 가지치기(Pruning)를 결합**한 형태입니다. 이를 통해 불필요한 탐색을 줄이면서도 모든 유효한 해를 빠짐없이 찾아내는 효율적이고 정확한 풀이법입니다.