
---
# 위상 정렬 (Topological Sort)

**위상 정렬**은 방향성이 있고 사이클이 없는 그래프(DAG, Directed Acyclic Graph)의 정점들을 **간선의 방향을 거스르지 않도록 나열**하는 것을 의미합니다. 즉, 어떤 정점 A에서 정점 B로 가는 간선이 있다면, 정렬된 결과에서는 반드시 A가 B보다 앞에 위치해야 합니다.

이 알고리즘은 작업들 간의 **선후 관계나 의존성**이 주어졌을 때, 이를 올바른 순서대로 처리하기 위해 사용됩니다.

-   **예시**: 대학교 선수과목, 프로젝트 빌드 순서, 작업 스케줄링 등
-   **핵심 조건**: 그래프에 **사이클(Cycle)**이 존재하면 위상 정렬은 불가능합니다. (A→B→C→A 와 같은 순환 의존성)



---

## 알고리즘 종류

위상 정렬을 구현하는 대표적인 두 가지 방법은 **칸 알고리즘(Kahn's Algorithm)**과 **DFS(깊이 우선 탐색) 기반 알고리즘**입니다.

### 1. 칸 알고리즘 (Kahn's Algorithm) - 큐 기반 접근

칸 알고리즘은 마치 대학교에서 선수과목을 모두 이수한 과목부터 수강 신청하는 과정과 유사하여 직관적입니다.

#### 핵심 아이디어

"현재 시점에서 바로 시작할 수 있는 작업(선행 작업이 없는 작업)부터 순서대로 처리해 나간다"는 아이디어에 기반합니다. 여기서 '선행 작업의 수'를 **진입 차수(In-degree)**라고 합니다.

#### 구현 방식: 반복문과 재귀

칸 알고리즘의 핵심 아이디어는 두 가지 방식으로 구현할 수 있습니다.

**가. 표준적인 반복문(Iterative) 방식**

가장 널리 알려진 방식으로, 별도의 작업 큐(Work Queue)를 사용합니다.

1.  모든 정점의 진입 차수를 계산합니다.
2.  진입 차수가 0인 모든 정점을 큐에 넣습니다.
3.  큐가 빌 때까지 다음을 **반복**합니다.
    a. 큐에서 정점을 꺼내 결과 리스트에 추가합니다.
    b. 꺼낸 정점과 연결된 이웃 정점들의 진입 차수를 1씩 감소시킵니다.
    c. 이웃 정점의 진입 차수가 0이 되면, 해당 정점을 큐에 추가합니다.

**나. 재귀(Recursive) 방식**

이 방식은 진입 차수 아이디어를 재귀적으로 풀어낸 독특한 접근법입니다. 별도의 작업 큐 없이 **결과 큐**와 재귀 함수만으로 동작합니다.

1.  `main` 함수에서 진입 차수가 0인 **초기 시작점**을 찾아 **결과 큐**에 넣습니다.
2.  그 시작점을 인자로 **재귀 함수 `topology_recursive(node)`를 호출**합니다.
3.  재귀 함수는 `node`와 연결된 이웃 노드들의 진입 차수를 1씩 줄입니다.
4.  만약 이웃 노드의 진입 차수가 0이 되면, 그 즉시 **결과 큐에 추가**하고, 해당 이웃 노드를 인자로 **자기 자신을 다시 호출**하여 탐색을 깊이 이어나갑니다.

이 방식은 진입 차수가 0이 되는 노드를 발견하는 즉시 그 노드를 따라 깊게 탐색을 진행한다는 점에서, 표준 방식의 너비 우선적(level-by-level) 처리와는 다른 동작 순서를 보입니다. 하지만 진입 차수에 기반하여 의존성을 해결한다는 핵심 원리는 동일합니다.

---

### 2. DFS 기반 알고리즘 - 스택 기반 접근

DFS 기반 알고리즘은 "가장 마지막에 처리해야 하는 작업부터 결정한다"는 역방향 아이디어에 기반합니다.

#### 핵심 아이디어

어떤 정점에서 출발하는 모든 경로를 탐색한 후, 더 이상 갈 곳이 없을 때 해당 정점의 탐색이 '종료'됩니다. 이 **탐색 종료 시점의 역순**이 바로 위상 정렬 순서가 됩니다.

#### 알고리즘 단계

1.  **초기 설정**: 모든 정점의 방문 여부를 기록할 배열과, 최종 결과를 담을 스택(Stack)을 준비합니다.
2.  **DFS 실행**: 모든 정점을 순회하며, 아직 방문하지 않은 정점에 대해 DFS를 재귀적으로 호출합니다.
3.  **스택에 추가**: DFS 함수 내에서, 현재 정점과 연결된 모든 경로의 탐색을 마친 후(재귀 호출이 끝난 후), 현재 정점을 스택에 추가합니다.
4.  **결과 확인**: 모든 정점에 대한 탐색이 끝나면, 스택에 쌓인 정점을 위에서부터 차례대로 꺼냅니다. 이 순서가 위상 정렬 결과입니다.

---

## 정확성 증명

### 칸 알고리즘의 정확성

**주장**: 정점 `u`는 그것을 가리키는 모든 선행 정점들이 처리된 후에만 큐에 들어간다.

**증명**:
1.  정점 `u`의 진입 차수는 `u`로 들어오는 선행 정점의 개수와 같습니다.
2.  `u`는 진입 차수가 0이 될 때만 처리 대상(큐에 추가)이 될 수 있습니다.
3.  `u`의 진입 차수는 `u`를 가리키는 선행 정점이 처리될 때마다 1씩 감소합니다.
4.  따라서 `u`의 진입 차수가 0이 되었다는 것은, `u`를 가리키던 모든 선행 정점이 이미 처리되었음을 의미합니다.
5.  이는 모든 간선 `v -> u`에 대해 `v`가 `u`보다 항상 먼저 처리됨을 보장하므로, 위상 정렬의 정의를 만족합니다. (이는 반복문, 재귀 방식 모두에 해당합니다.)

### DFS 기반 알고리즘의 정확성

**주장**: 어떤 간선 `u -> v`가 존재할 때, DFS의 종료 시점은 항상 `v`가 `u`보다 빠르다.

**증명**:
`u`에서 DFS를 시작했을 때 간선 `u -> v`를 만나는 경우를 생각해봅시다.

1.  **`v`를 아직 방문하지 않은 경우**: `dfs(u)`는 `dfs(v)`를 호출합니다. `dfs(v)`와 그 자손들에 대한 모든 재귀 호출이 끝나야 `dfs(u)`의 실행이 재개될 수 있습니다. 따라서 `v`의 탐색이 `u`의 탐색보다 먼저 종료되며, `v`가 `u`보다 먼저 스택에 추가됩니다.
2.  **`v`를 이미 방문한 경우**: 사이클이 없다면, `v`의 탐색은 이미 완전히 종료된 상태입니다. 따라서 `v`는 이미 스택에 있거나 먼저 추가될 것이고, `u`는 나중에 탐색이 종료되므로 `v`보다 늦게 스택에 추가됩니다.

두 경우 모두 `v`가 `u`보다 항상 먼저 스택에 쌓입니다. 스택은 후입선출(LIFO) 구조이므로, 나중에 결과를 꺼낼 때 `u`가 `v`보다 먼저 나오게 되어 위상 정렬의 정의를 만족합니다.