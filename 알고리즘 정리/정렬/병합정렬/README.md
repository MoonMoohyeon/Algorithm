## 📜 개념 및 원리

병합 정렬의 핵심 원리는 간단합니다. "정렬된 두 배열을 합치는 것은 쉽다"는 아이디어에서 출발하며, 다음과 같은 두 단계로 동작합니다.

1.  **분할 (Divide)** 🧩
    * 정렬되지 않은 배열을 **더 이상 나눌 수 없을 때까지** (배열의 크기가 1이 될 때까지) 재귀적으로 계속해서 절반으로 나눕니다. 크기가 1인 배열은 그 자체로 정렬된 상태로 간주합니다.

2.  **정복 및 결합 (Conquer and Combine)** 🤝
    * 분할된 부분 배열들을 다시 **정렬하면서 병합**합니다.
    * 두 개의 정렬된 부분 배열을 하나의 정렬된 배열로 합치는 과정을 반복하여, 최종적으로 전체 배열이 정렬되도록 만듭니다.

예를 들어, `[3, 7]`과 `[2, 8]`이라는 두 정렬된 배열을 병합하는 과정은 다음과 같습니다.

* 두 배열의 첫 번째 원소 `3`과 `2`를 비교하여 더 작은 `2`를 결과 배열에 넣습니다.
* 다음으로 `3`과 `8`을 비교하여 더 작은 `3`을 결과 배열에 넣습니다.
* 다음으로 `7`과 `8`을 비교하여 더 작은 `7`을 결과 배열에 넣습니다.
* 마지막으로 남은 `8`을 결과 배열에 넣습니다.
* 최종 결과: `[2, 3, 7, 8]`

***

## ⚙️ 동작 과정

`[6, 5, 3, 1, 8, 7, 2, 4]` 배열을 예시로 병합 정렬의 전체 과정을 살펴보겠습니다.

1.  **분할 단계 (Divide Phase)**
    * `[6, 5, 3, 1, 8, 7, 2, 4]`
    * `[6, 5, 3, 1]` | `[8, 7, 2, 4]`
    * `[6, 5]` | `[3, 1]` | `[8, 7]` | `[2, 4]`
    * `[6]` | `[5]` | `[3]` | `[1]` | `[8]` | `[7]` | `[2]` | `[4]`
        * 배열의 크기가 1이 되어 분할이 완료됩니다.

2.  **결합 단계 (Combine Phase)**
    * `[5, 6]` | `[1, 3]` | `[7, 8]` | `[2, 4]` (크기 1의 배열들을 정렬하며 병합)
    * `[1, 3, 5, 6]` | `[2, 4, 7, 8]` (크기 2의 배열들을 정렬하며 병합)
    * `[1, 2, 3, 4, 5, 6, 7, 8]` (크기 4의 배열들을 정렬하며 병합하여 최종 결과 도출)

***

## 🔍 정확성 증명

병합 정렬의 정확성은 **수학적 귀납법**과 **루프 불변성(Loop Invariant)**을 통해 증명할 수 있습니다.

#### 귀납법을 이용한 증명

배열의 크기 `$n$`에 대한 수학적 귀납법을 사용합니다.

1.  **기본 단계 (Base Case)**
    * 배열의 크기 `$n=1$`일 때, 이 배열은 이미 정렬된 상태입니다. 병합 정렬 알고리즘은 크기가 1인 배열에 대해 아무 작업도 하지 않고 반환하므로 명백히 참입니다.

2.  **귀납적 가정 (Inductive Hypothesis)**
    * 크기가 `$n$`보다 작은 임의의 배열, 즉 크기 `$k < n$`인 모든 배열에 대해 병합 정렬이 올바르게 동작한다고 가정합니다.

3.  **귀납적 단계 (Inductive Step)**
    * 크기가 `$n$`인 배열을 정렬하는 경우를 증명해야 합니다.
    * **분할**: 병합 정렬은 먼저 크기 `$n$`인 배열을 약 `$\lceil n/2 \rceil$`와 `$\lfloor n/2 \rfloor$`인 두 개의 부분 배열로 나눕니다. 이 두 부분 배열의 크기는 모두 `$n$`보다 작습니다.
    * **정복**: **귀납적 가정**에 따라, 재귀적으로 호출된 병합 정렬은 이 두 부분 배열을 **올바르게 정렬**합니다.
    * **결합**: 이제 남은 과제는 `merge` 함수가 **두 개의 정렬된 부분 배열**을 하나의 완전한 정렬된 배열로 올바르게 병합하는지를 보이는 것입니다. 이는 아래의 **루프 불변성**으로 증명할 수 있습니다.

#### `merge` 함수의 루프 불변성을 이용한 증명

`merge` 함수 내에서 두 부분 배열(L과 R)을 합치는 `while` 루프의 정확성은 **루프 불변성**으로 보일 수 있습니다.

* **루프 불변성(Loop Invariant)**: `while` 루프의 매 반복이 시작될 때마다, 결과 배열 `A`의 현재까지 채워진 부분(`A[start...k-1]`)은 L과 R의 원소들 중 가장 작은 원소들을 포함하며, 그 자체로 정렬되어 있다.

1.  **초기 조건 (Initialization)**: 루프가 처음 시작될 때, 결과 배열 `A`에 채워진 부분은 비어있습니다. 따라서 루프 불변성은 자명하게 성립합니다.

2.  **유지 조건 (Maintenance)**: 루프의 한 반복에서, `L[i]`와 `R[j]` 중 더 작은 값이 `A[k]`에 복사됩니다. `L`과 `R`은 이미 정렬되어 있으므로 `L[i]`와 `R[j]`는 각 배열에서 아직 복사되지 않은 가장 작은 값들입니다. 따라서 둘 중 더 작은 값을 `A`에 추가하는 것은 `A`의 정렬 상태를 유지합니다. 해당 인덱스(`i` 또는 `j`)와 `k`를 증가시킨 후에도 루프 불변성은 다음 반복을 위해 계속 유지됩니다.

3.  **종료 조건 (Termination)**: 루프는 `L` 또는 `R` 배열 중 하나의 모든 원소가 `A`로 복사되었을 때 종료됩니다. 종료 후, 남아있는 배열의 원소들은 이미 `A`에 복사된 모든 원소보다 큽니다. 이 남은 원소들을 순서대로 `A`의 뒷부분에 복사하면, `A`의 전체 범위가 올바르게 정렬됩니다.

결론적으로 `merge` 함수는 두 정렬된 부분 배열을 정확하게 하나의 정렬된 배열로 병합합니다. 따라서 귀납적 단계가 성립하며, 병합 정렬은 모든 크기의 배열에 대해 정확하게 동작함이 증명됩니다.