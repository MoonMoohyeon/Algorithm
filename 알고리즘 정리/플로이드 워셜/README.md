# 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)

플로이드-워셜 알고리즘은 그래프에서 **모든 노드 쌍 간의 최단 경로**를 찾는 알고리즘입니다. 가중치가 있는 방향 그래프(weighted directed graph)에서 사용되며, 음수 가중치를 가진 간선이 있어도 동작하지만 음수 가중치 순환(negative cycle)은 없어야 합니다.

이 알고리즘은 동적 계획법(Dynamic Programming)에 기반을 둡니다.

-----

## 알고리즘 설명 (Algorithm Explanation)

플로이드-워셜의 핵심 아이디어는 \*\*"거쳐갈 수 있는 정점"\*\*을 점진적으로 늘려가며 최단 경로를 갱신하는 것입니다.

알고리즘은 2차원 배열 `dist[i][j]`를 사용하여 `i`에서 `j`까지의 최단 경로 길이를 저장합니다. 이 배열은 처음에는 직접 연결된 간선의 가중치로 초기화됩니다 (연결되지 않았다면 무한대, 자기 자신은 0).

알고리즘의 중심에는 다음과 같은 3중 반복문이 있습니다.

```
for k from 1 to N:      // k: 거쳐갈 노드
  for i from 1 to N:    // i: 출발 노드
    for j from 1 to N:  // j: 도착 노드
      // i에서 j로 가는 기존 경로와, i에서 k를 거쳐 j로 가는 경로를 비교
      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### 동작 원리

`k`가 `1`일 때, 알고리즘은 1번 노드를 경유지로 사용하는 모든 경로를 고려하여 최단 경로를 갱신합니다. 예를 들어, `dist[i][j]`를 갱신할 때 "기존의 `i`에서 `j`로 가는 직접적인 경로"와 "`i` → `1` → `j`로 가는 새로운 경로" 중 더 짧은 경로를 선택합니다.

그다음 `k`가 `2`가 되면, 이제 1번과 2번 노드를 경유지로 사용할 수 있는 모든 경로를 고려합니다. 이 과정에서 `dist[i][k]`와 `dist[k][j]` 값은 이미 1번 노드를 경유했을 때의 최단 경로 정보가 반영된 상태이므로, 자연스럽게 ${1, 2}$번 노드를 모두 활용하는 최적의 경로를 찾을 수 있습니다.

이 과정을 `k`가 `N`이 될 때까지 반복하면, 결국 1번부터 N번까지의 모든 노드를 경유지로 사용할 수 있게 되므로 `dist` 배열에는 모든 노드 쌍 간의 최종 최단 경로가 저장됩니다.

### 점화식

이러한 아이디어를 점화식으로 표현하면 다음과 같습니다.
$D\_k[i][j]$를 \*\*"${1, 2, ..., k}$ 번 노드까지만 경유지로 사용하여 `i`에서 `j`로 가는 최단 경로"\*\*라고 정의합시다.

1.  **k를 경유하지 않는 경우:** 최단 경로는 ${1, 2, ..., k-1}$ 번 노드만 사용해서 `i`에서 `j`로 가는 경로와 같습니다.
      - 경로 길이: $D\_{k-1}[i][j]$
2.  **k를 경유하는 경우:** 최단 경로는 `i`에서 `k`로 간 후, `k`에서 `j`로 가는 경로의 합입니다. 이때 `i` → `k` 경로와 `k` → `j` 경로는 모두 ${1, 2, ..., k-1}$ 번 노드들만 경유지로 사용합니다.
      - 경로 길이: $D\_{k-1}[i][k] + D\_{k-1}[k][j]$

따라서, `k` 단계의 최단 경로는 이 두 경우 중 더 작은 값이 됩니다.

$$D_k[i][j] = \min(D_{k-1}[i][j], D_{k-1}[i][k] + D_{k-1}[k][j])$$

실제 구현에서는 공간 복잡도를 $O(N^2)$로 최적화하여 2차원 배열 하나만으로 이 점화식을 수행합니다.

-----

## 정확성 증명 (Proof of Correctness)

플로이드-워셜 알고리즘의 정확성은 \*\*귀납법(Induction)\*\*을 통해 증명할 수 있습니다.

**명제 $P(k)$**: 외부 반복문의 `k`번째 실행이 끝난 후, `dist[i][j]`는 중간 정점으로 `{1, 2, ..., k}`에 속한 정점들만 사용한 `i`에서 `j`까지의 최단 경로 길이를 가진다.

1.  **기초 단계 (Base Case: k=0)**
    반복문이 시작되기 전(`k=0`), `dist[i][j]`는 `i`와 `j`를 직접 잇는 간선의 가중치로 초기화됩니다. 이는 중간 정점을 하나도 사용하지 않는 최단 경로이므로, $P(0)$은 참입니다.

2.  **귀납 단계 (Inductive Step)**
    명제 $P(k-1)$이 참이라고 가정합시다. 즉, `k-1`번째 반복이 끝난 후 `dist[i][j]`는 `{1, ..., k-1}`의 정점들만 경유한 `i`\~`j` 최단 경로를 담고 있습니다. 이제 `k`번째 반복에서 $P(k)$가 참이 되는지 보이면 됩니다.

    `i`에서 `j`로 가는, 경유지로 `{1, ..., k}`에 속한 정점들만 사용하는 최단 경로 $\\pi$를 생각해봅시다. 이 경로는 두 가지 경우로 나뉩니다.

      * **경로 $\\pi$가 정점 `k`를 포함하지 않는 경우:**
        이 경로의 모든 경유지는 `{1, ..., k-1}`에만 속합니다. 귀납적 가정에 따라, 이 경로의 길이는 `k-1`번째 반복 후에 계산된 `dist[i][j]` 값과 같습니다. `k`번째 반복에서 `dist[i][j]`는 최소 `dist[i][j]` 값(이전 값)을 보장하므로 올바른 값을 가집니다.

      * **경로 $\\pi$가 정점 `k`를 포함하는 경우:**
        음수 순환이 없으므로 최단 경로는 같은 정점을 두 번 방문하지 않습니다. 따라서 경로 $\\pi$는 `i` → ... → `k` → ... → `j`의 형태를 가집니다. 이 경로는 `i`에서 `k`까지의 부분 경로 $\\pi\_1$과 `k`에서 `j`까지의 부분 경로 $\\pi\_2$로 나눌 수 있습니다.

          - $\\pi\_1$과 $\\pi\_2$의 모든 경유지는 `{1, ..., k-1}` 집합에만 속합니다.
          - 귀납적 가정에 의해, $\\pi\_1$의 길이는 `k-1`번째 반복 후의 `dist[i][k]`이고, $\\pi\_2$의 길이는 `dist[k][j]`입니다.
          - `k`번째 반복에서 알고리즘은 `dist[i][j]`를 `min(dist[i][j], dist[i][k] + dist[k][j])`로 갱신합니다. 이 연산은 `k`를 경유하는 새로운 최단 경로의 가능성을 정확히 계산하여 반영합니다.

    따라서 `k`번째 반복이 끝나면, `dist[i][j]`는 `k`를 경유하거나 경유하지 않는 두 경우를 모두 고려한 최단 경로 값을 가지게 됩니다. 이는 $P(k)$가 참임을 의미합니다.

3.  **종료 (Termination)**
    귀납법에 따라, 마지막 반복(`k=N`)이 끝나면 `dist[i][j]`에는 `{1, ..., N}`의 모든 정점을 경유지로 사용할 수 있는 `i`에서 `j`까지의 최단 경로 길이가 저장됩니다. 이는 그래프 전체의 모든 정점 쌍에 대한 최단 경로와 같습니다.