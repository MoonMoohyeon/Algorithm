# 유니온 파인드 (Union-Find) 알고리즘

`유니온 파인드(Union-Find)`는 \*\*서로소 집합(Disjoint Sets)\*\*을 관리하기 위한 효율적인 자료구조입니다. 이 자료구조는 여러 개의 노드가 있을 때, 특정 두 노드가 같은 집합에 속해 있는지 판별하고, 두 집합을 하나로 합치는 연산을 빠르게 수행하는 데 사용됩니다.

주요 연산은 다음과 같이 두 가지입니다.

1.  **`find(x)`**: 원소 x가 어떤 집합에 속해 있는지 찾아 그 집합의 \*\*대표(representative)\*\*를 반환합니다.
2.  **`union(x, y)`**: 원소 x가 속한 집합과 원소 y가 속한 집합을 하나로 합칩니다.

-----

## 핵심 개념

유니온 파인드는 집합을 **트리 구조**로 표현하여 동작합니다.

  * **집합 표현**: 같은 집합에 속한 원소들은 하나의 트리로 묶입니다.
  * **대표(Root)**: 트리의 루트 노드가 그 집합의 대표가 됩니다. 루트 노드는 부모가 자기 자신인 노드입니다. (`parent[i] == i`)
  * **`parent` 배열**: 각 원소의 부모 노드를 저장하는 1차원 배열 `parent`를 사용합니다.

### `find` 연산

`find(x)` 연산은 원소 `x`에서 시작하여 부모 노드를 계속 따라 올라가 트리의 루트, 즉 집합의 대표를 찾는 과정입니다.

```
find(x):
  if parent[x] == x:
    return x  // 루트에 도달하면 반환
  else:
    return find(parent[x]) // 부모를 따라 재귀적으로 탐색
```

### `union` 연산

`union(x, y)` 연산은 먼저 `find`를 통해 두 원소 `x`, `y`가 속한 집합의 대표(루트)를 각각 찾습니다. 두 루트가 다르면, 한쪽 트리의 루트를 다른 쪽 트리의 루트의 자식으로 만들어 두 트리를 합칩니다.

```
union(x, y):
  rootX = find(x)
  rootY = find(y)

  if rootX != rootY: // 두 원소가 다른 집합에 속할 경우
    parent[rootY] = rootX // y의 루트를 x의 루트 자식으로 편입
```

-----

## 최적화 기법

기본적인 방식의 유니온 파인드는 트리가 한쪽으로 치우쳐진 \*\*편향 트리(skewed tree)\*\*가 될 수 있습니다. 이 경우 `find` 연산의 시간 복잡도가 $O(N)$까지 증가할 수 있습니다. 이를 방지하고 거의 상수 시간에 가깝게 성능을 향상시키기 위해 다음 두 가지 최적화 기법이 반드시 사용됩니다.

### 1\. 경로 압축 (Path Compression)

`find` 연산을 수행하면서 거쳐 가는 모든 노드가 **직접 루트를 가리키도록** 부모 포인터를 갱신하는 기법입니다.

`find`가 실행될 때, `x`에서 루트까지의 경로에 있던 모든 노드들은 다음 `find` 호출 시 곧바로 루트에 접근할 수 있습니다. 이로 인해 트리의 높이가 급격히 낮아져 탐색 속도가 매우 빨라집니다.

```cpp
int find(int x) {
    if (parent[x] == x) return x;
    // 경로상의 모든 노드의 부모를 루트로 직접 갱신
    return parent[x] = find(parent[x]);
}
```

### 2\. 랭크/크기 기반 합치기 (Union by Rank/Size)

`union` 연산을 수행할 때, 두 트리를 임의로 합치지 않고 **정해진 규칙**에 따라 합치는 기법입니다. 이 규칙은 트리가 불필요하게 길어지는 것을 방지합니다.

  * **Union by Rank**: 트리의 \*\*높이(rank)\*\*를 기준으로, 랭크가 낮은 트리를 랭크가 높은 트리의 루트에 붙입니다. 만약 두 트리의 랭크가 같다면, 한쪽을 붙이고 루트가 된 노드의 랭크를 1 증가시킵니다.
  * **Union by Size**: 트리의 \*\*크기(노드 개수)\*\*를 기준으로, 크기가 작은 트리를 크기가 큰 트리의 루트에 붙입니다.

두 기법 모두 효과적이며, 경로 압축과 함께 사용될 때 강력한 성능을 보장합니다.

```cpp
// Union by Rank 예시
void union_sets(int a, int b) {
    a = find(a);
    b = find(b);
    if (a != b) {
        // 랭크가 낮은 쪽을 높은 쪽에 붙인다.
        if (rank[a] < rank[b]) swap(a, b);
        parent[b] = a;
        // 랭크가 같았다면, 합쳐진 후 루트의 랭크가 1 증가한다.
        if (rank[a] == rank[b]) rank[a]++;
    }
}
```

-----

## 정확성 증명

유니온 파인드 알고리즘의 정확성은 \*\*"같은 집합에 속한 모든 원소는 `find` 연산을 통해 항상 동일한 대표(루트)를 반환한다"\*\*는 불변성(invariant)에 기반합니다.

1.  **초기 상태**: `init()` 함수는 모든 원소 `i`에 대해 `parent[i] = i`로 설정합니다. 각 원소는 자기 자신만을 포함하는 집합의 대표이므로 초기 상태는 정확합니다.

2.  **`find` 연산의 정확성**:

      * `find(x)`는 `parent` 포인터를 따라 루트(대표)에 도달할 때까지 탐색합니다. 트리의 구조상 모든 노드는 단 하나의 루트를 가집니다. 따라서 `find(x)`는 항상 `x`가 속한 집합의 유일한 대표를 올바르게 반환합니다.
      * **경로 압축**은 `find` 경로상의 노드들의 `parent` 포인터를 루트로 직접 연결할 뿐, 해당 노드들이 속한 집합의 \*\*근본적인 소속(어떤 루트 아래에 있는지)\*\*을 바꾸지 않습니다. 따라서 연산의 정확성에 영향을 주지 않으면서 성능만 향상시킵니다.

3.  **`union` 연산의 정확성**:

      * `union(x, y)`는 두 원소의 대표 `rootX`와 `rootY`를 찾습니다.
      * 만약 `rootX == rootY`이면, 두 원소는 이미 같은 집합에 있으므로 아무런 변경을 하지 않습니다. 이는 정확합니다.
      * 만약 `rootX != rootY`이면, 한 대표(예: `rootY`)의 부모를 다른 대표(`rootX`)로 설정합니다. 이로써 `rootY`를 대표로 가졌던 모든 노드들은 이제 `parent` 포인터를 따라가면 최종적으로 `rootX`에 도달하게 됩니다. 결과적으로 두 집합의 모든 원소는 `rootX`라는 단일 대표를 공유하게 되므로, 두 집합이 올바르게 하나로 합쳐집니다.
      * **랭크/크기 기반 합치기** 최적화는 두 트리 중 어느 쪽을 루트로 삼을지 결정하는 규칙일 뿐, 두 집합을 하나로 합친다는 본질적인 결과를 변경하지 않습니다. 따라서 정확성을 해치지 않습니다.

결론적으로, 두 최적화 기법을 적용하더라도 유니온 파인드 알고리즘의 각 연산은 집합의 소속 관계를 정확하게 유지하고 갱신합니다.

-----

## 시간 복잡도

**경로 압축**과 **랭크/크기 기반 합치기**를 모두 적용했을 때, `m`개의 연산에 대한 총 시간 복잡도는 $O(m \\cdot \\alpha(n))$입니다.

여기서 $n$은 원소의 개수이며, $\\alpha(n)$은 \*\*애커만 함수의 역함수(Inverse Ackermann Function)\*\*입니다. 이 함수는 증가 속도가 극도로 느려서, 사실상 우리가 마주하는 모든 $n$ 값에 대해 5 미만의 값을 가집니다. 따라서 시간 복잡도는 **거의 상수 시간($O(1)$)에 가깝다**고 할 수 있습니다.

-----

## 활용 분야

  * **최소 신장 트리 (MST)**: 크루스칼(Kruskal) 알고리즘에서 간선(edge)을 추가할 때 사이클 생성 여부를 확인하는 데 사용됩니다.
  * **그래프의 연결 요소 (Connected Components)**: 그래프의 노드들을 순회하며 같은 연결 요소에 속하는지 판별하고 그룹화할 수 있습니다.
  * **네트워크 연결성 문제**: 두 단말기(노드)가 서로 연결되어 있는지 확인하는 데 사용됩니다.
  * **사이클 탐지 (Cycle Detection)**: 무방향 그래프에서 `union` 연산 시 두 원소가 이미 같은 집합에 속해 있다면, 이들을 연결하는 간선은 사이클을 형성합니다.