# Trie (Prefix Tree) 자료구조

`Trie`는 문자열을 효율적으로 저장하고 검색하기 위한 트리 형태의 자료구조입니다. 이름은 "검색"을 의미하는 \*\*"Re\<u\>trie\</u\>val"\*\*에서 유래했으며, \*\*접두사 트리(Prefix Tree)\*\*라고도 불립니다.

가장 큰 특징은 **문자열의 공통된 접두사(prefix)를 공유**하여 메모리를 절약하고 검색 속도를 높이는 것입니다.

-----

## 🤔 트라이란?

트라이는 각 노드가 문자 하나를 나타내는 트리 구조입니다. 루트 노드에서부터 특정 노드까지 이어지는 경로는 하나의 문자열(또는 접두사)을 의미합니다.

예를 들어, "car", "card", "cat"이라는 세 단어를 트라이에 저장하면, 'c' -\> 'a' 까지의 경로는 세 단어 모두가 공유하게 됩니다. 이처럼 접두사를 묶어 관리함으로써 구조적인 효율성을 얻습니다.

-----

## ✨ 장점 및 단점

### 👍 장점 (Advantages)

  * **매우 빠른 검색 속도**: 찾으려는 문자열의 길이를 `L`이라고 할 때, 검색, 삽입, 삭제의 시간 복잡도는 모두 **$O(L)$** 입니다. 이는 트라이에 저장된 전체 문자열의 수와 무관하게, 오직 검색하려는 문자열의 길이에만 의존하므로 매우 빠릅니다.
  * **접두사 기반 작업에 최적화**: 특정 접두사로 시작하는 모든 단어를 찾거나(자동 완성), 접두사가 존재하는지 확인하는(`startsWith`) 작업에 매우 효율적입니다.
  * **알파벳순 정렬**: 트리를 전위 순회(Pre-order Traversal)하면 저장된 모든 문자열을 알파벳순으로 쉽게 얻을 수 있습니다.

### 👎 단점 (Disadvantages)

  * **메모리 사용량**: 각 노드는 가능한 모든 문자에 대한 자식 포인터를 가져야 합니다. 예를 들어, 알파벳 소문자(26개)를 저장하는 노드는 26개의 포인터 공간을 가집니다. 만약 공통 접두사가 거의 없는 길고 다양한 문자열을 저장하면, 많은 노드들의 자식 포인터 대부분이 `null` 상태로 남아 **메모리 비효율**이 발생할 수 있습니다.

-----

## ⚙️ 동작 원리

트라이의 모든 노드는 두 가지 핵심 정보를 가집니다.

1.  **자식 노드 포인터**: 다음 문자를 가리키는 포인터 배열입니다. (예: `children[26]`)
2.  **단어의 끝 표시**: 현재 노드에서 끝나는 완전한 단어가 있는지를 나타내는 플래그입니다. (예: `isEndOfWord`)

### 1\. 삽입 (Insert)

1.  루트 노드에서 시작합니다.
2.  삽입할 단어의 각 문자를 차례대로 따라가며 자식 노드로 이동합니다.
3.  만약 해당 문자에 해당하는 자식 노드가 **없다면**, 새로운 노드를 생성하고 연결합니다.
4.  경로가 **있다면**, 기존 노드로 이동합니다.
5.  단어의 마지막 문자에 해당하는 노드에 도착하면, 해당 노드의 **`isEndOfWord` 플래그를 `true`로 설정**합니다.

### 2\. 검색 (Search)

1.  루트 노드에서 시작합니다.
2.  검색할 단어의 각 문자를 따라 자식 노드로 이동합니다.
3.  이동 중 경로가 끊기면(자식 노드가 없으면), 해당 단어는 트라이에 존재하지 않는 것입니다.
4.  단어의 마지막 문자까지 경로가 존재한다면, 마지막 노드의 **`isEndOfWord` 플래그가 `true`인지 반드시 확인**해야 합니다. 이 플래그가 `true`여야만 온전한 단어로 저장되었다고 판단할 수 있습니다.
      * *예시: "apple"만 저장된 트라이에서 "app"를 검색하면, 경로는 있지만 `isEndOfWord`가 `false`이므로 검색에 실패합니다.*

### 3\. 접두사 검색 (StartsWith)

1.  `검색(Search)` 과정과 거의 동일하게, 접두사의 경로를 따라 이동합니다.
2.  접두사의 마지막 문자까지 경로가 끊기지 않고 존재하기만 하면 `true`를 반환합니다. `isEndOfWord` 플래그는 확인할 필요가 없습니다.

-----

## 🧐 정확성 증명 (Proof of Correctness)

트라이 알고리즘이 왜 정확하게 동작하는지는 **루프 불변성(Loop Invariant)** 또는 귀납적 논증을 통해 간단히 증명할 수 있습니다.

> **핵심 명제**: 트라이에 대한 연산(삽입, 검색)이 끝난 후, 루트에서부터 어떤 경로가 나타내는 문자열이 `S`일 때, 이 경로가 트라이에 존재하는 것과 `S`가 이전에 삽입된 단어들의 접두사인 것은 동치이다. 또한, `S`가 온전한 단어로 삽입되었다면 경로의 마지막 노드의 `isEndOfWord`는 `true`이다.

1.  **기초 (Base Case)**

      * 비어있는 트라이(루트 노드만 존재)는 비어있는 문자열 집합을 올바르게 표현합니다. 위 명제는 참입니다.

2.  **유지 (Inductive Step)**

      * **삽입**: 트라이가 위 명제를 만족한다고 가정합시다. 새로운 단어 `W`를 삽입할 때, 알고리즘은 `W`의 접두사를 따라 노드를 탐색합니다.
          * 경로가 없으면 새로 생성합니다. 이는 `W`와 `W`의 모든 접두사가 이제 트라이 내에 경로로서 존재함을 보장합니다.
          * `W`의 마지막 문자에 해당하는 노드의 `isEndOfWord`를 `true`로 설정합니다. 이는 `W`가 이제 온전한 단어로 존재함을 명시합니다.
          * 따라서 삽입 후에도 위 명제는 여전히 참입니다.

3.  **결론 (Conclusion)**

      * **검색**: `search` 함수는 주어진 단어 `W`의 경로가 존재하는지 **그리고** 마지막 노드의 `isEndOfWord`가 `true`인지를 확인합니다. 이는 위 명제에 따라 `W`가 정확히 온전한 단어로 삽입되었는지를 검증하는 것과 같습니다. 따라서 `search`는 정확합니다.
      * **접두사 검색**: `startsWith` 함수는 주어진 접두사 `P`의 경로가 존재하는지만을 확인합니다. 이는 `P`가 삽입된 단어들 중 하나의 접두사인지를 검증하는 것과 같으므로 `startsWith` 역시 정확합니다.

결론적으로, 트라이의 각 연산은 핵심 명제를 깨뜨리지 않으므로 모든 연산이 올바르게 수행됨을 알 수 있습니다.