## 🧐 1. 매개변수 탐색

매개변수 탐색을 한마디로 정의하면, **최적화 문제를 결정 문제로 바꾸어 푸는 기법**입니다.

* **최적화 문제 (Optimization Problem)**: "가장 좋은 답은 무엇인가?"를 묻는 문제입니다.
    * 예: "만들 수 있는 랜선의 **최대** 길이는?", "필요한 **최소** 인출 금액은?"
* **결정 문제 (Decision Problem)**: "이 답이 가능한가?"를 묻는 **Yes/No** 문제입니다.
    * 예: "랜선 길이 X로 N개를 만들 수 **있는가**?", "인출 금액 K로 M번 안에 해결 **가능한가**?"

"가장 좋은 답이 뭐지?"라고 막막하게 고민하는 대신, "**이 값은 답이 될 수 있을까?**"라는 더 쉬운 질문을 반복해서 던지는 것이 핵심입니다.

매개변수 탐색은 바로 이 이분 탐색을 활용하여 최적의 답을 찾아냅니다.

---

## 2. 매개변수 탐색의 작동 원리

매개변수 탐색이 작동하기 위해서는 한 가지 중요한 전제 조건이 필요합니다. 바로 **단조성(Monotonicity)**입니다.

> **단조성**: 결정 문제의 답이 특정 값을 기준으로 'Yes'와 'No'가 명확하게 나뉘는 성질

예를 들어, '랜선 자르기' 문제에서 랜선 길이 200cm로 11개를 만들 수 있다면(**Yes**), 그보다 짧은 199cm로는 당연히 11개 이상을 만들 수 있습니다(**Yes**). 반대로 300cm로 만들 수 없다면(**No**), 그보다 긴 301cm로는 절대 만들 수 없습니다(**No**).

정답이 될 수 있는 값들의 배열이 있다면, 그 모습은 아래와 같습니다.
`[ Yes, Yes, Yes, ..., Yes, No, No, ..., No ]`

매개변수 탐색은 이 **Yes와 No의 경계**를 이분 탐색으로 찾아내는 과정입니다.

### 탐색 과정 (랜선 자르기 예시)

1.  **탐색 범위 설정**: 정답이 될 수 있는 최소값(`low`)과 최대값(`high`)을 설정합니다.
    * 랜선 길이의 최소값 `low = 1`, 최대값 `high = 가장 긴 랜선의 길이`
2.  **중간값(mid) 확인**: `mid = (low + high) / 2` 를 계산하여 중간 길이로 결정 문제를 풉니다.
    * `check(mid)`: "랜선 길이가 `mid`일 때 N개 이상 만들 수 있는가?"
3.  **범위 갱신**: `check(mid)`의 결과에 따라 범위를 좁힙니다.
    * **Yes (성공)**: `mid`는 일단 답이 될 수 있습니다. 하지만 우리는 '최대' 길이를 찾고 있으므로, 더 긴 길이도 가능한지 확인해야 합니다.
        * `result = mid` (현재 성공한 답을 저장)
        * `low = mid + 1` (더 긴 쪽을 탐색)
    * **No (실패)**: `mid`는 너무 깁니다. 더 짧은 길이에서 답을 찾아야 합니다.
        * `high = mid - 1` (더 짧은 쪽을 탐색)
4.  **종료**: `low`가 `high`보다 커지면 탐색이 종료되고, `result`에 저장된 값이 최종 정답이 됩니다.

---

## 3. 정확성 증명 (Proof of Correctness)

매개변수 탐색이 왜 항상 정확한 최적의 답을 찾아낼까요? 이는 **루프 불변성(Loop Invariant)**을 통해 증명할 수 있습니다. 루프 불변성이란, 반복문이 실행되는 동안 항상 참으로 유지되는 성질을 의미합니다.

> **루프 불변성**: 매 `while` 루프가 시작될 때, 우리가 찾는 **최적해(Optimal Solution)는 항상 `[low, high]` 범위 안에 존재하거나, `result` 변수에 저장되어 있다.**

### 증명 과정

1.  **초기화 (Initialization)**
    * 루프가 시작되기 전, `low`와 `high`는 각각 가능한 답의 최소값과 최대값으로 설정됩니다. 따라서 우리가 찾는 최적해는 반드시 `[low, high]` 범위 안에 포함됩니다. 불변성이 성립합니다.

2.  **유지 (Maintenance)**
    * 이제 루프의 한 단계에서 불변성이 유지되는지 봅시다. `mid = (low + high) / 2`로 계산된 값에 대해 `check(mid)`를 수행합니다.
    * **Case 1: `check(mid)`가 `true`일 경우 (최대값 찾기 문제)**
        * `mid`는 가능한 답이라는 의미입니다. 따라서 최적해는 `mid`이거나, `mid`보다 더 큰 값일 수 있습니다.
        * 이때 우리는 `result = mid`로 현재 가능한 답을 저장하고, `low = mid + 1`로 범위를 갱신합니다.
        * 이전의 최적해가 `mid`였다면 `result`에 저장되었고, `mid`보다 컸다면 여전히 새로운 `[low, high]` 범위 안에 존재하게 됩니다. 따라서 불변성이 유지됩니다.
    * **Case 2: `check(mid)`가 `false`일 경우 (최대값 찾기 문제)**
        * `mid`는 답이 될 수 없다는 의미입니다. 단조성에 의해 `mid`보다 큰 모든 값 또한 답이 될 수 없습니다.
        * 따라서 최적해는 반드시 `mid`보다 작은 값이어야 합니다.
        * `high = mid - 1`로 범위를 갱신하면, 최적해는 여전히 새로운 `[low, high]` 범위 안에 존재하게 됩니다. 불변성이 유지됩니다.
        *(최소값 찾기 문제의 경우에도 동일한 논리로 증명할 수 있습니다.)*

3.  **종료 (Termination)**
    * `while` 루프는 `low > high`일 때 종료됩니다. 이 시점은 탐색 범위가 더 이상 존재하지 않음을 의미합니다.
    * 루프의 유지 단계를 거치면서, 불가능한 답들은 모두 범위에서 제외되었고 가능한 답들은 `result`에 계속 갱신되었습니다.
    * 따라서 루프가 종료되었을 때 `result`에 남아있는 값은, **`check` 함수를 만족시키는 가장 마지막 값**, 즉 우리가 찾던 **최적해**가 됩니다.

이처럼 매개변수 탐색은 단조성을 가진 문제에 대해 이분 탐색을 적용하여, 매 단계마다 최적해가 포함된 범위를 절대 놓치지 않으면서 효율적으로 답을 찾아내는, 수학적으로 증명된 정확한 알고리즘입니다.