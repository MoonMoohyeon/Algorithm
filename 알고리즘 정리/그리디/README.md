## **Job Scheduling (작업 스케줄링) 알고리즘**

Job Scheduling 문제는 **활동 선택 문제(Activity Selection Problem)**라고도 불리며, 여러 작업이 있을 때 서로 겹치지 않으면서 가장 많은 수의 작업을 선택하는 것을 목표로 하는 대표적인 탐욕 알고리즘(Greedy Algorithm) 문제입니다.

가장 효율적인 해답을 찾는 방법은 '가장 빨리 끝나는 작업'을 우선으로 선택하는 것입니다.

### **알고리즘 설명**

1.  모든 작업을 **종료 시간**을 기준으로 오름차순으로 정렬합니다.
2.  정렬된 목록의 첫 번째 작업부터 선택합니다.
3.  이후, 이전에 선택한 작업과 시간이 **겹치지 않는** 다음 작업을 찾아 선택합니다. 이 과정을 목록의 끝까지 반복합니다.

---

## **정확성 증명 (Proof of Correctness)**

'가장 빨리 끝나는 작업을 선택하는 탐욕적인 방법이 항상 최적의 해를 보장하는가?'에 대한 증명입니다. 이 증명은 **교환 논증(Exchange Argument)** 기법을 사용합니다.

### **용어 정의**

* **탐욕해 (A)**: 위 알고리즘으로 찾은 해답. 즉, 우리가 만든 스케줄입니다.
* **최적해 (S)**: 가능한 가장 많은 수의 작업을 포함하는 이상적인 해답.

> **증명의 핵심**: 탐욕적인 선택이 최적해의 일부가 될 수 있음을 보인다. 즉, 탐욕적인 선택을 포함하도록 최적해를 수정해도 여전히 최적해임을 증명합니다.

### **증명 과정**

1.  탐욕해 **A**와 최적해 **S**의 작업들을 각각 종료 시간 순으로 정렬했다고 가정합니다.
    * A = {a₁, a₂, ..., aₖ}
    * S = {s₁, s₂, ..., sₘ}
    * 우리의 목표는 k와 m이 같음(k = m)을 보이는 것입니다.

2.  두 해답이 다른 첫 번째 지점을 찾습니다. 즉, `a₁=s₁, ..., aᵢ₋₁=sᵢ₋₁`이지만 `aᵢ ≠ sᵢ`인 지점 `i`가 있다고 가정합니다.

3.  **탐욕적 선택의 특성**
    * 알고리즘의 규칙에 따라 `aᵢ`는 `aᵢ₋₁` 이후에 수행할 수 있는 작업 중 **종료 시간이 가장 빠른 작업**입니다.
    * 따라서 `aᵢ`의 종료 시간은 `sᵢ`의 종료 시간보다 반드시 빠르거나 같습니다. (`종료(aᵢ) ≤ 종료(sᵢ)`)

4.  **교환 (Exchange)**
    * 최적해 **S**에서 `sᵢ`를 제거하고, 그 자리에 탐욕적인 선택이었던 `aᵢ`를 삽입하여 새로운 해 **S'**를 만듭니다.
    * **S'** = {s₁, ..., sᵢ₋₁, **aᵢ**, sᵢ₊₁, ..., sₘ}

5.  **교환 후 유효성 검증**
    * 새로 만든 **S'**가 여전히 유효한 스케줄(겹치지 않음)인지 확인해야 합니다.
        * `aᵢ`는 `sᵢ₋₁`(`=aᵢ₋₁`)과 겹치지 않습니다. (탐욕 알고리즘이 그렇게 선택했기 때문)
        * `aᵢ`는 `sᵢ₊₁`과 겹치지 않습니다. 왜냐하면 `종료(aᵢ) ≤ 종료(sᵢ)`이고, 원래 최적해 S에서 `종료(sᵢ) ≤ 시작(sᵢ₊₁)`이었기 때문입니다. `aᵢ`가 `sᵢ`보다 일찍 끝나므로 `sᵢ₊₁`과 겹칠 이유가 없습니다.

6.  **결론**
    * **S'**는 **S**와 동일한 작업 개수(m)를 가지면서, 겹치지 않는 유효한 스케줄입니다. 즉, **S'** 또한 최적해입니다.
    * 이 '교환' 과정을 반복하면, 최적해 **S**의 모든 작업을 탐욕해 **A**의 작업으로 점진적으로 바꿀 수 있습니다.
    * 이는 탐욕해 **A**가 최적해 **S**와 작업의 개수가 같다는 것을 의미합니다. (`k = m`)

따라서, **종료 시간이 빠른 순서로 작업을 선택하는 탐욕적인 접근 방식은 항상 최적의 해를 보장합니다.**