-----

## 다익스트라 (Dijkstra) 알고리즘

### 1\. 소개

다익스트라 알고리즘은 **단일 시작점 최단 경로 알고리즘**으로, 특정 한 정점에서부터 그래프 내의 **모든 다른 정점까지의 최단 거리를 찾는** 알고리즘입니다.

  * **모든 정점으로부터 모든 정점까지의 최단 거리를 찾을 때는 플로이드-워셜 알고리즘**을 사용합니다.
  * 다익스트라 알고리즘은 **모든 간선의 가중치가 양수**여야만 올바르게 동작합니다. **음수 가중치가 포함된 경우 벨만-포드 알고리즘**을 사용해야 합니다.

벨만-포드를 사용하지 않고 음의 간선을 해결하는 꼼수
= 모든 간선을 양으로 만들도록 제일 작은 음의 값의 절대값을 모든 간선에 더해준다.
-----

### 2\. 동작 방식

다익스트라 알고리즘은 \*\*탐욕법(Greedy Algorithm)\*\*을 기반으로 합니다.

1.  **시작 정점 설정 및 초기화**: 시작 정점의 거리는 0으로, 다른 모든 정점의 거리는 무한대로 설정합니다. 시작 정점을 우선순위 큐에 넣습니다.
2.  **가장 가까운 정점 선택**: 우선순위 큐에서 현재까지 발견된 거리 중 가장 작은 값을 가진 정점(노드)을 꺼냅니다.
3.  **최단 거리 갱신**: 해당 정점에서 인접한 모든 정점들을 탐색하며, 시작 정점에서부터 해당 인접 정점까지의 거리를 계산하고, 기존에 저장된 거리보다 짧으면 최단 거리를 갱신합니다.
4.  **우선순위 큐에 추가**: 거리가 갱신된 인접 정점을 우선순위 큐에 추가합니다.
5.  **반복**: 우선순위 큐가 빌 때까지 2\~4번 과정을 반복합니다.
6.  **종료 조건**: 우선순위 큐에서 꺼낸 값이 이미 방문 배열에 표시된 값(즉, 이미 최단 거리가 확정된 정점)보다 크다면, 이는 이미 더 짧은 경로를 찾았다는 의미이므로 해당 간선은 무시하고 다음으로 넘어갑니다.

-----

### 3\. 구현 방식

다익스트라 알고리즘을 구현하기 위해서는 주로 \*\*그래프, 우선순위 큐, 그리고 방문 상태(최단 거리 배열)\*\*가 필요합니다.

1.  **그래프 표현**: 인접 리스트 방식을 주로 사용합니다.

    ```cpp
    vector<pair<int, int>> graph[N];
    // N은 최대 정점의 개수
    // a와 b 노드가 가중치 c로 연결된 경우 (무방향 그래프 예시)
    graph[a].push_back(make_pair(c, b)); // {가중치, 연결된 노드}
    graph[b].push_back(make_pair(c, a)); // 무방향 그래프인 경우
    ```

      * `pair<int, int>`는 두 개의 정수 변수를 하나로 묶어 표현할 때 유용합니다. 여기서는 간선의 가중치와 연결된 정점 번호를 함께 저장합니다.

2.  **우선순위 큐 (Priority Queue)**:

    ```cpp
    priority_queue<pair<int, int>> pq;
    // 초기 시작 정점 삽입: {시작 정점까지의 거리, 시작 정점 번호}
    pq.push(make_pair(0, start)); 
    ```

      * C++의 `priority_queue`는 기본적으로 \*\*최대 힙(Max Heap)\*\*으로 동작합니다. 따라서 최단 거리를 찾기 위해서는 최소 힙처럼 동작하도록 조작해야 합니다.
      * 간선의 가중치를 **음수**로 넣어주면 가장 작은 가중치(절댓값은 가장 큰 음수)가 가장 높은 우선순위를 가지게 되어 최소 힙처럼 활용할 수 있습니다.

    <!-- end list -->

    ```cpp
    pq.push(make_pair(-next_distance, next_node)); 
    int current_distance = -pq.top().first; // 꺼낼 때 다시 양수로 복구
    ```

3.  **방문 상태 (최단 거리 저장 배열)**:
    각 정점까지의 현재까지의 최단 거리를 저장하는 배열입니다. 초기에는 모든 거리를 `INF` (무한대)로 설정하고, 시작 정점의 거리는 0으로 설정합니다.

    ```cpp
    int dist[N]; // 각 정점까지의 최단 거리를 저장하는 배열
    for (int i = 1; i <= N; i++) {
        dist[i] = INF; // 초기 상태는 모든 정점까지의 거리가 무한대
    }
    dist[start_node] = 0; // 시작 노드의 거리는 0
    ```

-----

### 4\. 증명

다익스트라 알고리즘의 정확성은 \*\*귀류법(Proof by Contradiction)\*\*을 통해 증명할 수 있습니다.

**개념 정의:**

  * **빨간색 노드 (Red Nodes)**: 시작 정점으로부터의 최단 경로가 이미 확정된 노드들의 집합입니다.
  * **파란색 노드 (Blue Nodes)**: 시작 정점으로부터의 최단 경로가 아직 확정되지 않은 노드들의 집합입니다.

**증명 아이디어 (귀류법):**

다익스트라 알고리즘이 항상 올바른 최단 경로를 찾는다는 것을 증명하기 위해, 다익스트라가 **어떤 노드 $v$에 대해 잘못된 (더 긴) 최단 경로를 찾았다**고 가정하고, 이 가정이 모순됨을 보입니다.

**초기 상태:**

  * 시작 노드 $S$는 빨간색 노드 (거리 0).
  * 다른 모든 노드는 파란색 노드 (거리 무한대 또는 직접 연결된 경우 간선 가중치).

**알고리즘의 동작:**

다익스트라 알고리즘은 매 단계마다 파란색 노드들 중에서 현재까지 계산된 거리가 가장 작은 노드를 선택하여 빨간색 노드로 만듭니다. 이 노드를 $v$라고 합시다. $v$가 빨간색 노드가 되면, $v$와 연결된 파란색 노드들의 거리를 갱신합니다.

**귀류법 가정:**

다익스트라 알고리즘이 어떤 노드 $v$를 빨간색 노드로 만들었는데, 실제로는 $v$에 대한 **더 짧은 최단 경로 $P\_{true}$가 존재한다**고 가정합시다. 즉, 다익스트라가 계산한 $v$까지의 거리 $d(v)$가 실제 최단 경로 길이 $d\_{true}(v)$보다 크다고 가정합니다: $d(v) \> d\_{true}(v)$.

**모순 찾기:**

$P\_{true}$ 경로 상에서, 시작 노드 $S$로부터 $v$로 가는 경로를 따라가면서, 처음으로 **빨간색 노드에서 파란색 노드로 넘어가는 간선**을 찾아봅시다. 이 간선을 $(u, w)$라고 하고, $u$는 빨간색 노드이고 $w$는 파란색 노드라고 합시다.

1.  **$u$는 빨간색 노드**: $u$는 이미 다익스트라에 의해 최단 거리가 확정된 노드이므로, $S$에서 $u$까지의 다익스트라가 계산한 거리 $d(u)$는 실제 최단 경로 길이 $d\_{true}(u)$와 같습니다. ($d(u) = d\_{true}(u)$)
2.  **$w$는 파란색 노드**: $w$는 아직 최단 거리가 확정되지 않은 노드입니다.
3.  **$P\_{true}$ 경로의 특성**: $S$에서 $w$까지의 실제 최단 경로 길이 $d\_{true}(w)$는 $S$에서 $u$까지의 실제 최단 경로 길이와 간선 $(u, w)$의 가중치를 더한 것과 같습니다: $d\_{true}(w) = d\_{true}(u) + \\text{weight}(u, w)$.
4.  **다익스트라의 선택 규칙**: $u$가 빨간색 노드로 선택될 당시, $u$는 모든 파란색 노드들 중에서 현재까지의 거리가 가장 작은 노드였습니다. 따라서 $d(u) \\leq d(x)$ for all blue nodes $x$. 특히, $d(u) \\leq d(w)$.

**이제 모순을 도출합니다:**

우리는 $d(v) \> d\_{true}(v)$ 라고 가정했습니다.
$P\_{true}$ 경로의 특성상 $w$는 $v$보다 $S$로부터 $P\_{true}$ 경로 상에서 더 일찍 나타나거나 같은 위치에 있을 수 있습니다. 따라서 $d\_{true}(w) \\le d\_{true}(v)$.

$d\_{true}(w) = d\_{true}(u) + \\text{weight}(u, w)$
또한, $d(u) = d\_{true}(u)$ 이므로,
$d\_{true}(w) = d(u) + \\text{weight}(u, w)$.

$u$가 빨간색 노드로 확정될 당시 $d(u)$는 파란색 노드 중 가장 작은 거리였으므로, $d(u) \\le d(w)$입니다.
하지만 $w$는 여전히 파란색 노드이고, $d\_{true}(w)$는 $w$의 실제 최단 거리입니다.

만약 $d(v) \> d\_{true}(v)$라면, $P\_{true}$ 경로 상에 있는 어떤 파란색 노드 $w$는 $d(w)$가 $d(v)$보다 작아야 합니다 (왜냐하면 $P\_{true}$는 $v$까지의 실제 최단 경로이고, $w$는 그 경로 상에 있기 때문입니다).
즉, $d\_{true}(w) \< d(w)$가 될 수 있습니다.

$d(u) \\le d(w)$ (다익스트라의 선택 규칙)
$d(u) = d\_{true}(u)$ (이미 확정된 노드)
$d\_{true}(w) = d\_{true}(u) + \\text{weight}(u,w) = d(u) + \\text{weight}(u,w)$

여기서 핵심은 $w$가 여전히 파란색 노드이고 $d(w)$가 $d(u) + \\text{weight}(u, w)$로 갱신되었을 것이라는 점입니다.
만약 $d(v)$가 실제 최단 경로보다 길다면, $v$가 선택되기 전에 $P\_{true}$ 경로 상에 있는 어떤 파란색 노드 $w$가 $v$보다 먼저 선택되었어야 합니다. 왜냐하면 그 노드 $w$의 실제 최단 거리가 $v$의 실제 최단 거리보다 작고, 다익스트라는 항상 현재까지 가장 작은 거리를 가진 노드를 선택하기 때문입니다.

즉, $P\_{true}$ 경로 상의 노드 $w$가 $u$에 인접해 있고 $w$가 아직 파란색 노드일 때, 다익스트라는 $d(w)$를 $d(u) + \\text{weight}(u,w)$로 갱신합니다.
이 값은 $d\_{true}(w)$와 같거나 큽니다 (등호는 $P\_{true}$ 경로가 다익스트라가 찾는 경로와 일치할 때).
우리는 $d(v) \> d\_{true}(v)$라고 가정했는데, 다익스트라의 동작 방식에 따르면 $v$가 빨간색 노드로 선택될 당시 $d(v)$는 모든 파란색 노드 중에서 가장 작은 값이었습니다.
만약 더 짧은 실제 경로가 존재한다면 ($d\_{true}(v) \< d(v)$), 그 경로 상의 어떤 파란색 노드 $x$의 현재 거리 $d(x)$가 $d(v)$보다 작았어야 합니다. 그런데 $v$가 선택되었다는 것은 다른 모든 파란색 노드의 현재 거리가 $d(v)$보다 크거나 같다는 뜻입니다.

이는 **다익스트라가 $v$를 선택할 때, $d(v)$가 모든 파란색 노드들의 현재 거리 중 가장 작았다는 사실**과 **$d(v) \> d\_{true}(v)$라는 가정**이 모순됨을 의미합니다.
따라서 다익스트라 알고리즘은 항상 올바른 최단 경로를 찾습니다.

-----