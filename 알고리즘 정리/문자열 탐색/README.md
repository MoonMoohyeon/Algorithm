# Algorithm
알고리즘 문제해결전략 연습하기
KMP 알고리즘은 텍스트에서 특정 패턴을 매우 효율적으로 찾아내는 알고리즘입니다. 핵심은, **문자열 비교에 실패했을 때, 이전에 일치했던 정보를 재활용하여 불필요한 비교를 건너뛰는 것**입니다.

-----

### \#\# 1. 소개: 무엇이 다른가? 🤔

가장 간단한(Naïve) 문자열 탐색 방식은 텍스트의 첫 문자부터 패턴을 비교하고, 실패하면 텍스트의 다음 문자로 이동해 다시 처음부터 패턴을 비교합니다.

  - **텍스트**: `ABCABCA`
  - **패턴**: `ABCA`

<!-- end list -->

1.  `ABC`까지 일치, `A`와 `A`가 아닌 `B`에서 불일치.
    ```
    ABCABCA
    ABCA
      ^ 불일치
    ```
2.  (단순한 방식) 텍스트의 두 번째 문자인 `B`부터 다시 패턴 전체를 비교 시작.
    ```
    ABCABCA
     ABCA  -> 처음부터 다시 비교 (비효율!)
    ```

**KMP 알고리즘**은 바로 이 비효율을 개선합니다. 1번 단계에서 `ABC`까지 일치했다는 정보를 버리지 않습니다. 패턴 `ABCA`의 마지막에 일치했던 `A`가 패턴의 시작 `A`와 같다는 점을 활용해, 패턴을 한 칸만 옮기는 대신 더 멀리 건너뛸 수 있습니다.

> **핵심 아이디어**: 불일치가 발생한 지점 이전에, 얼마나 유용한 정보(반복되는 부분)가 있었는지 미리 계산해두고, 이를 활용해 패턴을 최적의 위치로 '점프'시킨다.

-----

### \#\# 2. 설명: 어떻게 동작하는가? ⚙️

KMP는 두 단계로 동작합니다.

#### **1단계: LPS 배열 (부분 일치 테이블) 생성**

KMP의 마법은 **LPS (Longest Proper Prefix which is also Suffix)** 배열에 있습니다. 이름은 복잡하지만 개념은 간단합니다.

> **LPS[i]** = `pattern[0...i]` 문자열에서, **접두사(prefix)와 접미사(suffix)가 일치하는 가장 긴 길이** (단, 자기 자신은 제외)

예를 들어, 패턴 `P = "ABACABAB"`의 LPS 배열을 만들어 보겠습니다.

| i | `P[0...i]` | 접두사 | 접미사 | 일치하는 가장 긴 것 | LPS[i] |
| :-: | :---: | :---: | :---: | :---: | :---: |
| 0 | `A` | - | - | - | **0** |
| 1 | `AB` | `A` | `B` | - | **0** |
| 2 | `ABA` | `A`, `AB` | `A`, `BA` | `A` | **1** |
| 3 | `ABAC` | `A`, `AB`, `ABA` | `C`, `AC`, `BAC` | - | **0** |
| 4 | `ABACA` | `A`, `AB`,... | `A`, `CA`,... | `A` | **1** |
| 5 | `ABACAB` | `A`, `AB`,... | `B`, `AB`,... | `AB` | **2** |
| 6 | `ABACABA`| `A`, `AB`,... | `A`, `BA`,... | `ABA` | **3** |
| 7 | `ABACABAB`| `A`, `AB`,...| `B`, `AB`,... | `ABAB` | **4** |

이렇게 생성된 LPS 배열 `[0, 0, 1, 0, 1, 2, 3, 4]`는 패턴의 '자가 중복'에 대한 정보를 담고 있습니다.

#### **2단계: LPS 배열을 이용한 탐색**

이제 텍스트 `T`와 패턴 `P`를 비교하며 `LPS` 배열을 활용합니다.

  - `textIndex`와 `patternIndex` 두 개의 포인터를 사용합니다.

<!-- end list -->

1.  **문자가 일치할 경우**: `textIndex`와 `patternIndex`를 모두 1씩 증가시킵니다.
2.  **문자가 불일치할 경우**:
      - 이때 `textIndex`는 **절대 뒤로 돌아가지 않습니다.**
      - 대신 `patternIndex`를 `lps[patternIndex - 1]` 값으로 갱신(점프)합니다.

**왜 이것이 가능할까요?**

`T` = `... A B A C A B A` **C** `...`
`P` = `   A B A C A B A ` **B**
`^ (patternIndex = 7) 불일치 발생!`

  - `patternIndex` 7에서 불일치가 발생하기 전까지, 텍스트의 `ABACABA`와 패턴의 `ABACABA`는 일치했습니다.
  - 이때 `lps[patternIndex - 1]` 즉 `lps[6]`의 값은 **3**입니다.
  - 이 값 **3**은 "우리가 방금 비교했던 `ABACABA`라는 문자열은, 길이 3짜리 접두사(`ABA`)와 접미사(`ABA`)가 똑같다"는 의미입니다.
  - 따라서, 우리는 텍스트의 `...ABA` 부분과 패턴의 접두사 `ABA`가 일치한다는 사실을 이미 알고 있으므로, 패턴을 그 위치로 바로 '점프'시켜서 다음 비교를 이어갈 수 있습니다.
  - `patternIndex`는 **3**이 되고, `textIndex`는 그대로 둔 채 `T[...C...]`와 `P[3]`(`C`)을 비교합니다.

이 '점프' 과정 덕분에, 텍스트를 다시 읽는 비효율이 사라집니다.

-----

### \#\# 3. 정확성 증명 (귀납적 접근) 🧐

KMP 알고리즘이 왜 항상 정확한 결과를 내고, 어떤 경우도 놓치지 않는지 간단히 증명할 수 있습니다.

**핵심 명제**: KMP 알고리즘은 패턴의 모든 출현을 찾으며, 텍스트 포인터(`textIndex`)는 절대 뒤로 물러서지 않는다.

1.  **기본 가정**: `textIndex = i`, `patternIndex = j`에서 `T[i]`와 `P[j]`가 다르다고 가정합시다. 이 불일치 이전에 `T[i-j ... i-1]`과 `P[0 ... j-1]`은 일치한 상태입니다.

2.  **놓칠 수 있는 경우는?**: 만약 패턴의 또 다른 시작점이 우리가 건너뛴 위치에 존재한다면, 그 시작점은 `T[i-j+1]`과 `T[i-1]` 사이 어딘가에 있어야 합니다.

3.  **LPS의 역할**: 만약 `T[i-k ... i-1]`에서 시작하는 패턴이 존재한다면, 이는 `P[0 ... k-1]`이 `P[0 ... j-1]`의 접미사와 같다는 것을 의미합니다.

      - `T[i-k ... i-1]` == `P[0 ... k-1]`
      - `T[i-k ... i-1]` == `P[j-k ... j-1]` (기존 일치 부분의 접미사)
      - 따라서 `P[0 ... k-1]` == `P[j-k ... j-1]` (패턴의 접두사 == 패턴의 접미사)

4.  **결론**: `lps[j-1]`은 위 조건을 만족하는 **가장 긴** 접두사-접미사의 길이 `k`를 저장하고 있습니다. 따라서 `patternIndex`를 `lps[j-1]`로 옮기는 것은, 불일치가 발생한 현 상황에서 **다음에 시도해볼 수 있는 가장 가능성 높은 최적의 위치**로 패턴을 이동시키는 것입니다. 이보다 짧은 다른 모든 가능한 일치 지점들은, `lps` 값을 연쇄적으로 따라가면 결국 모두 확인되게 됩니다.

따라서, LPS 배열을 이용한 점프는 어떤 가능한 일치도 건너뛰지 않으므로 **정확성**이 보장됩니다. 또한 `textIndex`가 항상 전진하므로 알고리즘이 선형 시간 복잡도 `O(텍스트길이 + 패턴길이)`에 완료됨이 보장됩니다.