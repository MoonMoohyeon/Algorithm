# 투 포인터 알고리즘 (Two Pointers Algorithm)

투 포인터 알고리즘은 주로 **정렬된 배열**이나 리스트에서 특정 조건을 만족하는 쌍(pair)이나 부분 배열(subarray)을 효율적으로 찾는 데 사용되는 기법입니다. 배열의 양 끝에서 시작하는 두 개의 포인터(인덱스)를 점차 안쪽으로 이동시키며 탐색 범위를 좁혀나가는 방식으로 동작합니다.

이 문서에서는 투 포인터 알고리즘의 **정확성(Correctness)** 을 간단한 증명을 통해 설명합니다.

## 알고리즘의 정확성 증명 (Proof of Correctness)

투 포인터의 정확성은 **'매 단계에서 정답이 될 수 없는 탐색 공간을 확실하게 배제하며, 이 과정에서 실제 정답을 놓치지 않는다'** 는 논리에 기반합니다.

가장 대표적인 예시인 **"오름차순으로 정렬된 배열에서 두 수의 합이 특정 값 `S`가 되는 쌍 찾기"** 문제로 증명해 보겠습니다.

### 1\. 문제 설정

  - **배열**: 오름차순으로 정렬된 배열 `A`
  - **포인터**: `start` (배열의 시작, 인덱스 `0`)와 `end` (배열의 끝, 인덱스 `n-1`)
  - **목표**: `A[i] + A[j] == S`를 만족하는 인덱스 쌍 `(i, j)` 찾기
  - **알고리즘 로직**:
    1.  `current_sum = A[start] + A[end]`
    2.  만약 `current_sum > S` 이면, 합을 줄여야 하므로 `end` 포인터를 1 감소시킨다. (`end--`)
    3.  만약 `current_sum < S` 이면, 합을 늘려야 하므로 `start` 포인터를 1 증가시킨다. (`start++`)
    4.  `start`와 `end`가 교차할 때까지 위 과정을 반복한다.

<!-- end list -->

```python
def two_pointer_sum(arr, target):
    start, end = 0, len(arr) - 1
    while start < end:
        current_sum = arr[start] + arr[end]
        if current_sum == target:
            return (start, end)
        elif current_sum > target:
            end -= 1
        else:
            start += 1
    return None
```

### 2\. 귀류법을 이용한 증명 (Proof by Contradiction)

> **가정**: 만약 정답 쌍 `(i, j)` (단, `i < j`)이 존재함에도 불구하고, 알고리즘이 이 쌍을 **찾지 못하고 지나친다**고 가정해 봅시다.

이 가정이 참이라면, 아래 두 가지 시나리오 중 하나가 발생해야 합니다.

#### 시나리오 1: `start` 포인터가 `i`를 먼저 지나친 경우

  - `start` 포인터가 `i`를 지나쳤다는 것은, `start`가 `i`에 위치했을 때 `A[i] + A[end]`의 합이 `S`보다 컸다는 의미입니다.
  - `A[i] + A[end] > S`
  - 이때의 `end` 포인터는 정답 인덱스인 `j`보다 반드시 오른쪽에 있습니다 (`end > j`). 만약 `end <= j` 였다면 `A[i] + A[end]`는 `S`보다 클 수 없기 때문입니다. (`A`는 오름차순 정렬)
  - 알고리즘의 규칙에 따르면, 합이 `S`보다 크므로 `end` 포인터를 감소시켜야 합니다.
  - **그런데 `start` 포인터가 `i`를 지나쳐 `i+1`로 이동했다는 것은 `start`를 증가시켰다는 의미이므로, 이는 알고리즘의 규칙과 모순됩니다.**
  - 따라서 `start` 포인터는 `end`가 `j`에 도달하기 전에 `i`를 지나칠 수 없습니다.

#### 시나리오 2: `end` 포인터가 `j`를 먼저 지나친 경우

  - `end` 포인터가 `j`를 지나쳤다는 것은, `end`가 `j`에 위치했을 때 `A[start] + A[j]`의 합이 `S`보다 작았다는 의미입니다.
  - `A[start] + A[j] < S`
  - 이때의 `start` 포인터는 정답 인덱스인 `i`보다 반드시 왼쪽에 있습니다 (`start < i`). 만약 `start >= i` 였다면 `A[start] + A[j]`는 `S`보다 작을 수 없기 때문입니다.
  - 알고리즘의 규칙에 따르면, 합이 `S`보다 작으므로 `start` 포인터를 증가시켜야 합니다.
  - **그런데 `end` 포인터가 `j`를 지나쳐 `j-1`로 이동했다는 것은 `end`를 감소시켰다는 의미이므로, 이 또한 알고리즘 규칙과 모순됩니다.**
  - 따라서 `end` 포인터는 `start`가 `i`에 도달하기 전에 `j`를 지나칠 수 없습니다.

### 3\. 결론

두 시나리오 모두 **모순**이 발생하므로, "알고리즘이 정답 쌍을 찾지 못하고 지나친다"는 원래의 가정은 **거짓**입니다.

따라서 투 포인터 알고리즘은 매 단계에서 정답이 될 수 없는 선택지를 **안전하게(safely)** 배제하며, 만약 해답이 존재한다면 반드시 그 해답을 찾게 됩니다. 이것이 투 포인터 알고리즘의 **정확성**을 보장합니다.