#include <iostream>
#include <algorithm>
using namespace std;

// N: 물품의 수, K: 배낭이 버틸 수 있는 최대 무게
int N, K;

// DP[i][w] : i번째 물건까지 고려하고, 배낭의 용량이 w일 때의 최대 가치
int DP[101][100001] = { {0, } }; 
int weights[101] = { 0, }; // 각 물건의 무게를 저장하는 배열
int values[101] = { 0, };  // 각 물건의 가치를 저장하는 배열

int main(void)
{
    // 물품의 수(N)와 배낭의 최대 무게(K)를 입력받습니다.
    scanf("%d %d", &N, &K);

    // 각 물품의 무게(W)와 가치(V)를 입력받아 배열에 저장합니다.
    for (int i = 1; i <= N; i++)
    {
        int W, V;
        scanf("%d %d", &W, &V);
        weights[i] = W;
        values[i] = V;
    }

    // --- DP 테이블 채우기 (핵심 로직) ---
    // i는 현재 고려하고 있는 물건의 인덱스입니다. (1번 물건부터 N번 물건까지 순차적으로 고려)
    for (int i = 1; i <= N; i++)
    {
        // w는 현재 고려하고 있는 배낭의 용량입니다. (1부터 최대 용량 K까지)
        for (int w = 1; w <= K; w++)
        {
            // Case 1: 현재 물건(i)의 무게가 배낭 용량(w)보다 커서 넣을 수 없는 경우
            if (weights[i] > w) 
            {
                // i번째 물건을 넣는 것은 불가능하므로, 
                // i-1번째 물건까지 고려했을 때 용량 w에서의 최적값과 동일합니다.
                DP[i][w] = DP[i - 1][w];
            }
            // Case 2: 현재 물건(i)을 배낭에 넣을 수 있는 경우
            else 
            {
                // 선택지 1: i번째 물건을 넣지 않는다.
                // 이 경우의 가치는 i-1번째 물건까지 고려했을 때 용량 w에서의 최적값입니다.
                int dont_put = DP[i - 1][w]; 

                // 선택지 2: i번째 물건을 넣는다.
                // 이 경우의 가치는 (i번째 물건의 가치) + (i-1개의 물건으로, 현재 용량w에서 i번째 물건의 무게를 뺀 용량을 채우는 최적값) 입니다.
                int put = values[i] + DP[i - 1][w - weights[i]];
                
                // 두 선택지 중 더 가치가 높은 쪽을 선택하여 현재의 최적값으로 저장합니다.
                // 이를 통해 DP 테이블의 모든 값은 각 상황에서의 최적값임이 보장됩니다.
                DP[i][w] = max(dont_put, put);
            }
        }
    }

    printf("%d\n", DP[N][K]);

    return 0;
}