#include <iostream>
#include <string>

// -------------------------------------------------------------------
// 섹션 구분을 위한 도우미 함수
// -------------------------------------------------------------------
void print_divider(const std::string& title) {
    std::cout << "\n// ---------------------------------------------------\n";
    std::cout << "// " << title << "\n";
    std::cout << "// ---------------------------------------------------\n";
}

void memory_leak_example() {
    // 이 함수는 메모리 누수를 보여주기 위한 예시입니다.
    std::cout << "  메모리 누수 함수 진입..." << std::endl;
    int* leak_ptr = new int(100);
    std::cout << "  'new int(100)'으로 힙에 메모리 할당. 주소: " << leak_ptr << std::endl;
    // 함수가 종료될 때 'delete leak_ptr;'를 호출하지 않았습니다!
    // 따라서 leak_ptr 포인터 변수 자체는 사라지지만,
    // 이 포인터가 가리키던 힙 메모리 공간(4바이트)은 해제되지 않고 계속 남아있게 됩니다.
    // 이 메모리에 접근할 방법은 이제 없으며, 이것이 바로 '메모리 누수'입니다.
    std::cout << "  함수 종료. delete를 호출하지 않아 메모리 누수 발생!" << std::endl;
}


int main() {
    // -------------------------------------------------------------------
    // 1 & 2. 정적/동적 할당과 메모리 영역
    // -------------------------------------------------------------------
    print_divider("1 & 2. 정적/동적 할당과 메모리 영역");
    // C++ 프로그램은 메모리를 크게 4가지 영역으로 사용합니다: 코드, 데이터, 스택, 힙

    // [정적 할당 (Static Allocation)]
    // - 대상: 전역 변수, 정적(static) 변수, 그리고 '스택(Stack)' 영역에 할당되는 지역 변수
    // - 시점: 프로그램 '컴파일' 시점에 필요한 메모리 크기가 결정됩니다.
    // - 특징:
    //   - 컴파일러가 메모리 관리를 자동으로 해줘서 매우 편리하고 안전합니다.
    //   - 함수가 호출되면 스택에 쌓이고, 함수가 끝나면 자동으로 사라집니다. (LIFO: Last-In, First-Out)
    //   - 크기가 고정되어 있고, 상대적으로 작습니다.
    int static_var = 10; // main 함수 스택에 4바이트 할당
    std::cout << "정적 할당된 변수 static_var의 주소(스택): " << &static_var << std::endl;

    // [동적 할당 (Dynamic Allocation)]
    // - 대상: 프로그래머가 직접 관리하는 '힙(Heap)' 영역
    // - 시점: 프로그램 '실행 중(Runtime)'에 필요한 만큼 메모리를 할당받습니다.
    // - 특징:
    //   - 프로그램 실행 상황에 따라 필요한 만큼의 메모리를 유연하게 사용할 수 있습니다.
    //   - 프로그래머가 new/delete를 사용해 직접 할당하고 해제해야 하는 책임이 있습니다.
    //   - 스택보다 훨씬 큰 메모리 공간을 사용할 수 있습니다.


    // -------------------------------------------------------------------
    // 3. 동적 할당 연산자 (new, delete)
    // -------------------------------------------------------------------
    print_divider("3. 동적 할당 연산자 (new, delete)");
    
    // 단일 변수 동적 할당
    int* ptr1 = new int; // 힙(Heap) 영역에 int 하나를 저장할 공간(4바이트)을 할당하고, 그 주소를 ptr1에 저장
    *ptr1 = 20;
    std::cout << "동적 할당된 ptr1이 가리키는 값: " << *ptr1 << std::endl;
    std::cout << "ptr1이 가리키는 주소(힙): " << ptr1 << std::endl;
    delete ptr1; // 할당받았던 메모리를 반드시 해제!

    // 배열 동적 할당
    int* arr_ptr = new int[5]; // int 5개를 저장할 공간(20바이트)을 연속적으로 할당
    std::cout << "동적 할당된 배열 arr_ptr의 주소(힙): " << arr_ptr << std::endl;
    for (int i = 0; i < 5; i++) {
        arr_ptr[i] = (i + 1) * 10;
        std::cout << "  arr_ptr[" << i << "] = " << arr_ptr[i] << std::endl;
    }
    delete[] arr_ptr; // 'new[]'로 할당한 배열은 반드시 'delete[]'로 해제해야 합니다!


    // -------------------------------------------------------------------
    // 4. delete 사용 시 유의 사항
    // -------------------------------------------------------------------
    print_divider("4. delete 사용 시 유의 사항");
    
    int* p = new int(55);
    std::cout << "p의 주소: " << p << ", 값: " << *p << std::endl;
    delete p; // 정상적인 해제

    // [주의 1] 이중 해제 (Double Free)
    // delete p; // 이미 해제된 메모리를 또 해제하려고 하면 프로그램이 비정상 종료될 수 있습니다. (매우 위험!)

    // [주의 2] 댕글링 포인터 (Dangling Pointer)
    // delete를 호출하면 포인터 변수 p 자체가 사라지는 것이 아니라, p가 가리키던 '메모리 공간'만 해제됩니다.
    // p는 여전히 해제된 메모리의 주소를 갖고 있는데, 이를 '댕글링 포인터'라고 합니다.
    // 이 포인터를 통해 해당 메모리에 접근하면 예측 불가능한 오류가 발생합니다.
    // std::cout << "해제 후 p의 값: " << *p << std::endl; // 미정의 동작(Undefined Behavior)

    // [해결책] 포인터를 해제한 후에는 nullptr로 초기화하는 습관을 들이는 것이 안전합니다.
    p = nullptr; // 또는 p = NULL;
    if (p != nullptr) {
        // 이제 이 코드는 실행되지 않으므로 안전합니다.
        std::cout << "이 메시지는 보이지 않습니다." << std::endl;
    }


    // -------------------------------------------------------------------
    // 5. 동적 할당 메모리 초기화
    // -------------------------------------------------------------------
    print_divider("5. 동적 할당 메모리 초기화");

    // 단일 변수 초기화: new 타입(초기값)
    int* init_ptr1 = new int(100);
    std::cout << "초기화된 단일 변수: " << *init_ptr1 << std::endl;
    delete init_ptr1;

    // 배열 초기화 (C++11 이상): new 타입[크기]{초기값 목록}
    int* init_arr = new int[5]{1, 2, 3, 4, 5};
    std::cout << "초기화된 배열: ";
    for (int i = 0; i < 5; i++) {
        std::cout << init_arr[i] << " ";
    }
    std::cout << std::endl;
    delete[] init_arr;


    // -------------------------------------------------------------------
    // 6. 2차원 배열 동적 할당
    // -------------------------------------------------------------------
    print_divider("6. 2차원 배열 동적 할당");
    int rows = 3;
    int cols = 4;

    // 2차원 배열은 '포인터의 배열'을 이용해 구현하는 것이 일반적입니다.
    // 1. 먼저 각 행의 시작 주소를 저장할 '포인터 배열'을 동적 할당합니다.
    int** matrix = new int*[rows];

    // 2. 각 행(포인터)을 순회하며, 실제 데이터가 저장될 열 공간을 동적 할당합니다.
    for (int i = 0; i < rows; i++) {
        matrix[i] = new int[cols];
    }

    // 값 할당 및 사용
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = (i * cols) + j + 1;
            std::cout << matrix[i][j] << "\t";
        }
        std::cout << std::endl;
    }

    // 해제는 할당의 '역순'으로 해야 합니다!
    // 1. 각 행의 열 공간을 먼저 해제합니다.
    for (int i = 0; i < rows; i++) {
        delete[] matrix[i];
    }
    // 2. 마지막으로 행의 시작 주소를 담았던 포인터 배열을 해제합니다.
    delete[] matrix;
    std::cout << "2차원 배열 메모리 해제 완료!" << std::endl;


    // -------------------------------------------------------------------
    // 7. 메모리 누수 (Memory Leak)
    // -------------------------------------------------------------------
    print_divider("7. 메모리 누수 (Memory Leak)");
    // 메모리 누수: 'new'로 할당한 힙 메모리를 'delete'로 해제하는 것을 잊어버려,
    // 해당 메모리를 프로그램이 더 이상 사용할 수 없게 되는 현상입니다.
    // 프로그램이 오래 실행될수록 누수된 메모리가 쌓여 시스템 성능을 저하시키고, 결국 다운될 수 있습니다.
    
    memory_leak_example(); // 메모리 누수를 발생시키는 함수 호출
    
    std::cout << "\n메인 함수 종료. 프로그램이 끝나면 운영체제가 남은 메모리를 정리해주지만," << std::endl;
    std::cout << "프로그램 실행 중에는 누수된 메모리가 계속 문제를 일으킬 수 있습니다." << std::endl;

    return 0;
}
