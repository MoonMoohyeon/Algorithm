#include <iostream>
#include <vector>   // 향상된 for문을 위해 vector를 사용합니다.
#include <string>

// -------------------------------------------------------------------
// 섹션 구분을 위한 도우미 함수
// -------------------------------------------------------------------
void print_divider(const std::string& title) {
    std::cout << "\n// ---------------------------------------------------\n";
    std::cout << "// " << title << "\n";
    std::cout << "// ---------------------------------------------------\n";
}

int main() {
    // -------------------------------------------------------------------
    // 1. 연산자 우선순위 (Operator Precedence)
    // -------------------------------------------------------------------
    print_divider("1. 연산자 우선순위");
    // 연산자 우선순위는 어떤 연산을 먼저 수행할지 정해진 규칙입니다.
    // 곱셈/나눗셈이 덧셈/뺄셈보다 먼저 계산되는 것과 같습니다.
    int a = 10, b = 5, c = 2;
    int result1 = a + b * c; // b * c (10)가 먼저 계산되고, a (10)와 더해집니다.
    std::cout << "a + b * c = " << result1 << std::endl; // 결과: 20

    // 괄호'()'를 사용하면 우선순위를 강제로 변경할 수 있습니다.
    // 괄호 안의 연산이 항상 가장 먼저 수행됩니다.
    // Tip: 우선순위가 헷갈리거나 코드를 명확하게 만들고 싶을 땐 괄호를 적극적으로 사용하세요!
    int result2 = (a + b) * c; // (a + b) (15)가 먼저 계산되고, c (2)와 곱해집니다.
    std::cout << "(a + b) * c = " << result2 << std::endl; // 결과: 30


    // -------------------------------------------------------------------
    // 2. 콤마 연산자 (Comma Operator)
    // -------------------------------------------------------------------
    print_divider("2. 콤마 연산자");
    // 콤마(,) 연산자는 왼쪽 피연산자를 먼저 실행하고, 그 결과를 버린 뒤,
    // 오른쪽 피연산자를 실행하고 그 결과를 반환합니다.
    // 주로 for문의 초기화나 증감식에서 여러 변수를 다룰 때 사용됩니다.
    int x, y;
    // (x=1, y=x+2) -> x에 1을 할당하고, y에 x+2(3)을 할당합니다. 전체 식의 결과는 3이 됩니다.
    int result3 = (x = 1, y = x + 2);
    std::cout << "콤마 연산자 결과: x=" << x << ", y=" << y << ", result3=" << result3 << std::endl;

    // for문에서의 활용 예시
    for (int i = 0, j = 5; i <= 5; i++, j--) {
        std::cout << "i=" << i << ", j=" << j << std::endl;
    }


    // -------------------------------------------------------------------
    // 3. 조건문 (Conditional Statements)
    // -------------------------------------------------------------------
    print_divider("3. 조건문");
    int score = 85;

    // if-else if-else: 조건에 따라 다른 코드를 실행합니다.
    if (score >= 90) {
        std::cout << "학점: A" << std::endl;
    } else if (score >= 80) {
        std::cout << "학점: B" << std::endl; // score가 85이므로 이 블록이 실행됩니다.
    } else {
        std::cout << "학점: C 이하" << std::endl;
    }

    // switch: 특정 변수의 값에 따라 여러 경우 중 하나를 선택하여 실행합니다.
    // case 끝에는 break를 넣어주는 것이 일반적입니다. break가 없으면 다음 case가 연달아 실행됩니다.
    char blood_type = 'A';
    switch (blood_type) {
        case 'A':
            std::cout << "혈액형은 A형입니다." << std::endl;
            break;
        case 'B':
            std::cout << "혈액형은 B형입니다." << std::endl;
            break;
        case 'O':
            std::cout << "혈액형은 O형입니다." << std::endl;
            break;
        default: // 일치하는 case가 없을 때 실행됩니다.
            std::cout << "알 수 없는 혈액형입니다." << std::endl;
            break;
    }


    // -------------------------------------------------------------------
    // 4. for문 (향상된 for문 포함)
    // -------------------------------------------------------------------
    print_divider("4. for문");

    // 기본 for문: (초기식; 조건식; 증감식) 구조로, 정해진 횟수만큼 반복합니다.
    std::cout << "[기본 for문]" << std::endl;
    for (int i = 0; i < 5; i++) {
        std::cout << "현재 i 값: " << i << std::endl;
    }

    // 향상된 for문 (Range-based for loop, C++11 이상):
    // 배열이나 벡터 같은 컨테이너의 모든 요소를 처음부터 끝까지 순회할 때 매우 편리합니다.
    std::cout << "\n[향상된 for문]" << std::endl;
    std::vector<std::string> fruits = {"사과", "바나나", "딸기"};
    for (const auto& fruit : fruits) {
        // fruits 벡터의 각 요소가 순서대로 fruit 변수에 복사(또는 참조)되어 블록이 실행됩니다.
        std::cout << "과일: " << fruit << std::endl;
    }


    // -------------------------------------------------------------------
    // 5. 배열 선언과 초기화
    // -------------------------------------------------------------------
    print_divider("5. 배열 선언과 초기화");
    
    // 배열: 같은 타입의 여러 데이터를 연속된 메모리 공간에 저장하는 자료구조입니다.
    int numbers1[5]; // 5개의 int를 담을 수 있는 배열 선언 (값은 쓰레기값으로 초기화)
    
    // 선언과 동시에 초기화
    int numbers2[5] = {10, 20, 30, 40, 50};
    
    // 초기화 값의 개수에 맞춰 크기가 자동 결정
    int numbers3[] = {1, 2, 3}; // 컴파일러가 크기를 3으로 자동 설정

    // 배열의 이름(numbers2)은 배열의 시작 주소를 가리키는 포인터처럼 동작합니다.
    std::cout << "numbers2 배열의 시작 주소: " << numbers2 << std::endl;
    std::cout << "numbers2 배열의 첫 번째 원소: " << numbers2[0] << std::endl;


    // -------------------------------------------------------------------
    // 6. 배열 크기 및 접근
    // -------------------------------------------------------------------
    print_divider("6. 배열 크기 및 접근");

    // sizeof 연산자를 이용해 배열의 전체 크기(바이트)와 원소 하나의 크기를 나누면 배열의 길이를 알 수 있습니다.
    int arr_len = sizeof(numbers2) / sizeof(numbers2[0]);
    std::cout << "numbers2 배열의 길이: " << arr_len << std::endl;

    // 배열 원소 접근: '배열이름[인덱스]' 형태로 접근합니다. 인덱스는 0부터 시작합니다.
    std::cout << "numbers2[0]: " << numbers2[0] << std::endl; // 첫 번째 원소
    std::cout << "numbers2[2]: " << numbers2[2] << std::endl; // 세 번째 원소
    std::cout << "numbers2[4]: " << numbers2[4] << std::endl; // 마지막 원소

    // 배열의 범위를 벗어난 접근은 매우 위험하며, 예측할 수 없는 오류를 발생시킵니다. (주의!)
    // std::cout << numbers2[5] << std::endl; // 미정의 동작(Undefined Behavior)


    // -------------------------------------------------------------------
    // 7. 2차원 배열
    // -------------------------------------------------------------------
    print_divider("7. 2차원 배열");

    // 2차원 배열은 배열의 배열, 즉 행과 열을 갖는 테이블 형태로 데이터를 저장합니다.
    // [행의 개수][열의 개수]
    int matrix[2][3] = {
        {1, 2, 3}, // 첫 번째 행
        {4, 5, 6}  // 두 번째 행
    };

    // 2차원 배열의 원소에 접근하려면 행과 열의 인덱스를 모두 사용해야 합니다.
    std::cout << "matrix[0][1] (0행 1열): " << matrix[0][1] << std::endl; // 결과: 2
    std::cout << "matrix[1][2] (1행 2열): " << matrix[1][2] << std::endl; // 결과: 6

    // 중첩 for문을 사용하여 2차원 배열의 모든 요소를 순회할 수 있습니다.
    std::cout << "\n[2차원 배열 전체 출력]" << std::endl;
    for (int i = 0; i < 2; i++) { // 행 순회 (i는 행 인덱스)
        for (int j = 0; j < 3; j++) { // 열 순회 (j는 열 인덱스)
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl; // 한 행 출력이 끝나면 줄바꿈
    }

    return 0;
}
