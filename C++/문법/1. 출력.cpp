#include <iostream>  // cout, endl, fixed 등 표준 입출력 스트림을 사용하기 위해 필요합니다.
#include <iomanip>   // setw, setfill, setprecision 등 출력 형식을 조작하는 기능을 사용하기 위해 필요합니다.
#include <string>    // std::string 타입을 사용하기 위해 필요합니다.

// -------------------------------------------------------------------
// 섹션 구분을 위한 도우미 함수
// -------------------------------------------------------------------
void print_divider(const std::string& title) {
    // std::cout은 C++의 표준 출력 스트림 객체로, 보통 콘솔 화면에 연결됩니다.
    // std::endl은 줄바꿈 문자를 출력하고, 출력 버퍼를 비우는(flush) 역할을 합니다.
    std::cout << "\n// ---------------------------------------------------\n";
    std::cout << "// " << title << "\n";
    std::cout << "// ---------------------------------------------------\n";
}

int main(int argc, char** argv) {
    // using namespace std;
    // C++의 표준 라이브러리 기능들은 'std'라는 이름 공간(namespace) 안에 있습니다.
    // 이 선언은 std::cout, std::endl 대신 cout, endl처럼 짧게 쓰도록 해줍니다.
    using namespace std;

    // -------------------------------------------------------------------
    // 기본 출력과 스트림 버퍼
    // -------------------------------------------------------------------
    print_divider("기본 출력과 스트림 버퍼");

    // '<<' (스트림 삽입 연산자): 오른쪽의 데이터를 왼쪽의 출력 스트림(cout)에 보냅니다.
    // cout은 데이터를 바로 화면에 표시하지 않고 '버퍼'라는 임시 공간에 모았다가,
    // 특정 조건이 되면 한 번에 내보내 처리 효율을 높입니다.
    cout << "Hello C++!" << endl;

    cout << "이 내용은 버퍼에 잠시 머물 수 있습니다. ";

    // flush(): 버퍼에 있는 데이터를 강제로 목적지(콘솔)로 내보내고 비웁니다.
    // 버퍼가 비워지는 경우:
    // 1. endl을 만났을 때
    // 2. 버퍼가 가득 찼을 때
    // 3. 프로그램이 종료될 때
    // 4. cin 같은 입력 요청이 있을 때
    // 5. flush()를 명시적으로 호출했을 때
    cout.flush();
    cout << "<- flush()로 바로 출력됨!" << endl;


    // -------------------------------------------------------------------
    // 출력 서식 지정 1: 너비와 채움 (iomanip)
    // -------------------------------------------------------------------
    print_divider("출력 서식 지정 1: 너비와 채움 (iomanip)");
    
    int number = 123;
    cout << "원본 숫자: " << number << endl;

    // setw(n): 'set width'의 약자. 앞으로 출력될 데이터가 차지할 공간을 n칸으로 설정합니다.
    // 이 설정은 딱 '한 번만' 유효하며, 기본적으로 오른쪽 정렬됩니다.
    cout << "기본(공백 채움): |" << setw(10) << number << "|" << endl;

    // setfill('c'): 'set fill'의 약자. setw로 생긴 빈칸을 채울 문자를 'c'로 설정합니다.
    // 이 설정은 다시 바꾸기 전까지 '계속 유지'됩니다.
    cout << setfill('0'); // 빈칸을 '0'으로 채우도록 설정
    cout << "setfill('0') 적용: |" << setw(10) << number << "|" << endl;
    
    // setfill의 효과는 계속 유지되므로, setw만 다시 호출하면 됩니다.
    cout << "setfill 효과 유지: |" << setw(10) << 45 << "|" << endl;

    // 채울 문자를 '*'로 변경해 봅시다.
    cout << setfill('*');
    cout << "setfill('*') 적용: |" << setw(10) << number << "|" << endl;

    // setw는 일회성이므로 루프 안에서 계속 호출해주어야 합니다.
    cout << "\n[루프에서 setw(6) 적용 예시]" << endl;
    cout << setfill(' '); // 채움 문자를 다시 공백으로 초기화
    for (int i = 1; i < 10000; i *= 10) {
        cout << "|" << setw(6) << i << "|" << endl;
    }

    // -------------------------------------------------------------------
    // 출력 서식 지정 2: 소수점 정밀도 (iomanip)
    // -------------------------------------------------------------------
    print_divider("출력 서식 지정 2: 소수점 정밀도 (iomanip)");

    double pi = 3.1415926535;
    cout << "원본 double 값: " << pi << endl << endl;

    // precision(n): 출력할 숫자의 정밀도를 n자리로 설정합니다.
    // 기본 상태에서는 '전체 유효 숫자'의 개수를 의미합니다.
    cout << "precision(4) 기본: " << setprecision(4) << pi << " (전체 4자리)" << endl;
    cout << "precision(8) 기본: " << setprecision(8) << pi << " (전체 8자리)" << endl << endl;

    // fixed: 소수점 표기 방식을 고정합니다.
    // 이 설정을 하면 precision(n)이 '소수점 이하' 자릿수를 의미하게 됩니다.
    cout << fixed; // 소수점 표기 방식 고정!
    cout << "fixed + precision(4): " << setprecision(4) << pi << " (소수점 이하 4자리)" << endl;
    cout << "fixed + precision(8): " << setprecision(8) << pi << " (소수점 이하 8자리)" << endl << endl;

    // 고정된 서식을 해제하려면 unsetf()를 사용합니다.
    cout.unsetf(ios::fixed);
    cout << "unsetf(ios::fixed) 후: " << pi << " (다시 기본 방식으로 출력)" << endl;

    return 0;
}
