#include <iostream>
#include <string>
#include <vector>

// =================================================================================
// 전역 객체의 생성과 소멸
// =================================================================================
// 전역 객체(Global Object): main 함수가 시작되기 전에 생성되고, 프로그램이 완전히 종료될 때 소멸됩니다.
// 이 객체의 생성자는 main 함수보다 먼저 호출됩니다.
class GlobalObject {
public:
    GlobalObject(const std::string& name) {
        std::cout << "[전역 객체 \"" << name << "\" 생성됨 (main 시작 전)]" << std::endl;
    }
    ~GlobalObject() {
        std::cout << "[전역 객체 소멸됨 (main 종료 후)]" << std::endl;
    }
};

GlobalObject g_obj("나전역"); // 전역 객체 생성

// =================================================================================
// 예제 클래스: Gadget
// =================================================================================
class Gadget {
private:
    std::string name_; // 멤버 변수임을 나타내는 '_' (멤버 변수임을 구분하기 위한 관례)
    const int id_; // const 멤버: 반드시 생성자에서 초기화되어야 합니다.
    int& another_ref_; // 참조(reference) 멤버: 반드시 생성자에서 초기화되어야 합니다.

    // =============================================================================
    // 프라이빗 생성자 (Private Constructor)
    // =============================================================================
    // 생성자를 private 영역에 두면 클래스 외부에서 객체를 직접 생성하는 것을 막을 수 있습니다.
    // 이는 '싱글톤 패턴'처럼 객체 생성을 특정 메서드로 제어하고 싶을 때 유용합니다.
    Gadget(std::string name, int id, int& another) 
        : name_(name), id_(id), another_ref_(another) {
        std::cout << "    (프라이빗 생성자 호출) Gadget " << name_ << " (ID: " << id_ << ") 생성" << std::endl;
    }


public:
    // =============================================================================
    // 생성자 (Constructor) 와 그 특징
    // =============================================================================
    // - 객체가 생성될 때 '자동으로' 호출되는 특별한 멤버 함수입니다.
    // - 주된 역할은 객체의 멤버 변수들을 초기화하는 '셋업(setup)' 작업입니다.
    // - 특징:
    //   1. 이름이 클래스 이름과 완전히 동일합니다.
    //   2. 반환형(return type)을 명시하지 않습니다. (void도 안 됨)
    //   3. 오버로딩(overloading)이 가능하여 여러 형태의 생성자를 가질 수 있습니다.

    // =============================================================================
    // 디폴트 생성자 (Default Constructor)
    // =============================================================================
    // 매개변수가 없는 생성자를 디폴트 생성자라고 합니다.
    // 사용자가 아무런 생성자도 만들지 않으면 컴파일러가 자동으로 보이지 않는 디폴트 생성자를 만들어줍니다.
    // 하지만 사용자가 하나라도 생성자를 만들면, 컴파일러는 더 이상 자동으로 만들어주지 않습니다.
    // 이 생성자는 아래 '위임 생성자'의 타겟이 됩니다.
    Gadget() : name_("기본 가젯"), id_(-1), another_ref_(*new int(0)) {
        std::cout << "    (디폴트 생성자 호출) Gadget " << name_ << " (ID: " << id_ << ") 생성" << std::endl;
    }

    // =============================================================================
    // 멤버 이니셜라이저 (Member Initializer List)
    // =============================================================================
    // 콜론(:) 뒤에 멤버 변수를 초기화하는 구문입니다. 생성자 몸체 `{}`에서 값을 대입하는 것보다 효율적입니다.
    // '초기화'는 변수가 태어날 때 값을 주는 것이고, '대입'은 태어난 후에 값을 덮어쓰는 것입니다.
    //
    // **반드시 이니셜라이저를 사용해야 하는 경우:**
    // 1. const 멤버 변수 (한 번 초기화되면 바꿀 수 없으므로)
    // 2. 참조(Reference, &) 멤버 변수 (선언과 동시에 참조할 대상을 지정해야 하므로)
    // 3. 부모 클래스의 생성자를 호출할 때 (상속 시)
    // 4. 멤버 변수가 디폴트 생성자가 없는 다른 클래스의 객체일 때
    //
    // 이 생성자는 아래 '위임 생성자'의 '타겟 생성자'가 됩니다.
    Gadget(std::string name) : name_(name), id_(-2), another_ref_(*new int(0)) {
        std::cout << "    (타겟 생성자 호출) Gadget " << name_ << " (ID: " << id_ << ") 생성" << std::endl;
    }

    // =============================================================================
    // 위임 생성자 (Delegating Constructor)
    // =============================================================================
    // C++11부터 가능해진 기능으로, 한 생성자가 자신의 다른 생성자를 호출하여 초기화를 위임하는 것입니다.
    // 코드 중복을 줄이는 데 매우 유용합니다.
    // 아래 생성자는 이름과 ID를 받아서, 이름만 받는 위 '타겟 생성자'를 호출합니다.
    Gadget(std::string name, int id) : Gadget(name) { // name을 인자로 타겟 생성자에게 초기화 위임
        std::cout << "    (위임 생성자 실행) ID를 " << id << "로 설정" << std::endl;
        // name_의 초기화는 타겟 생성자가 이미 처리했습니다.
        // id_는 const 멤버이므로, 여기서 값을 바꿀 수 없습니다. (위임 생성자의 한계)
    }

    // 프라이빗 생성자를 호출해주는 static public 메서드 (팩토리 메서드 패턴)
    static Gadget* createPrivateInstance(std::string name, int id, int& another) {
        return new Gadget(name, id, another);
    }
    
    // =============================================================================
    // 소멸자 (Destructor) 와 그 특징
    // =============================================================================
    // - 객체가 소멸될 때 (메모리에서 사라질 때) '자동으로' 호출되는 특별한 멤버 함수입니다.
    // - 주된 역할은 객체가 사용하던 자원(메모리, 파일, 네트워크 연결 등)을 정리하는 '클린업(cleanup)' 작업입니다.
    // - 특징:
    //   1. 이름이 클래스 이름 앞에 물결표(~)를 붙인 형태입니다. (e.g., ~Gadget)
    //   2. 반환형과 매개변수를 가질 수 없습니다.
    //   3. 클래스당 단 하나만 존재할 수 있습니다. (오버로딩 불가)
    ~Gadget() {
        std::cout << "    (소멸자 호출) Gadget " << name_ << " (ID: " << id_ << ") 소멸 <<<<" << std::endl;
    }

    void status() {
        std::cout << "  > Gadget 상태: " << name_ << " (ID: " << id_ << ")" << std::endl;
    }
};


int main() {
    std::cout << "main 함수 시작\n" << std::endl;

    // =============================================================================
    // 객체 생성 및 생성자 실행 과정 & 지역 객체
    // =============================================================================
    // 지역 객체(Local Object): 함수나 코드 블록 `{}` 내에 선언된 객체.
    // 해당 함수나 블록이 시작될 때 생성되고, 끝나면 소멸됩니다.
    
    std::cout << "--- 1. 일반적인 지역 객체 생성 ---\n";
    Gadget g1("스마트폰", 101); // Gadget(string, int) 생성자 호출
    g1.status();

    std::cout << "\n--- 2. 위임 생성자 동작 확인 ---\n";
    // 위임 생성자 Gadget(string, int)가 타겟 생성자 Gadget(string)을 먼저 호출합니다.
    Gadget g2("스마트워치", 202); 
    g2.status();

    // =============================================================================
    // 생성자와 소멸자의 실행 순서
    // =============================================================================
    // 객체는 생성된 순서의 '역순'으로 소멸됩니다. (스택처럼 Last-In, First-Out)
    std::cout << "\n--- 3. 중첩된 범위에서의 생성/소멸 순서 ---\n";
    Gadget outer("바깥 객체", 301);
    {
        std::cout << "  (내부 블록 진입)\n";
        Gadget inner("안쪽 객체", 302);
        outer.status();
        inner.status();
        std::cout << "  (내부 블록 탈출)\n";
    } // inner 객체가 여기서 먼저 소멸됩니다.
    std::cout << "내부 블록 밖으로 나옴\n";

    // =============================================================================
    // 객체 배열과 객체 포인터 배열
    // =============================================================================
    std::cout << "\n--- 4. 객체 배열의 생성과 소멸 ---\n";
    // 객체 배열을 생성하면, 배열의 각 요소에 대해 '디폴트 생성자'가 호출됩니다.
    Gadget gadget_array[2];
    gadget_array[0].status();

    std::cout << "\n--- 5. 객체 포인터 배열 ---\n";
    // 포인터 배열은 포인터를 담을 공간만 만들 뿐, 객체를 직접 생성하지 않습니다.
    // 따라서 생성자가 호출되지 않습니다.
    Gadget* gadget_ptr_array[2]; 
    std::cout << "  > 포인터 배열만 선언됨 (객체 생성 X)\n";
    
    // new 키워드를 사용해 동적으로 객체를 생성해야 생성자가 호출됩니다.
    gadget_ptr_array[0] = new Gadget("드론", 401);
    gadget_ptr_array[1] = new Gadget("태블릿", 402);

    // 동적으로 할당한 객체는 delete 키워드로 직접 해제해야 소멸자가 호출됩니다.
    // 해제하지 않으면 메모리 누수(memory leak)가 발생합니다.
    delete gadget_ptr_array[0];
    delete gadget_ptr_array[1];

    std::cout << "\n--- 6. 프라이빗 생성자 테스트 ---\n";
    // Gadget g3("프라이빗", 501); // 컴파일 에러! private 생성자는 직접 호출 불가
    int dummy_ref_val = 501;
    Gadget* g_private = Gadget::createPrivateInstance("비밀 가젯", 501, dummy_ref_val);
    g_private->status();
    delete g_private; // 역시 동적 할당했으므로 delete 필요


    std::cout << "\nmain 함수 종료 (지역 객체들이 역순으로 소멸됩니다)\n" << std::endl;
    return 0;
} // main 함수가 끝나면 g2, g1, outer, gadget_array 순서로 소멸됩니다.
  // 그 후 마지막으로 전역 객체 g_obj가 소멸됩니다.